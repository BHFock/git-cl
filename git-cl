#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# BSD 3-Clause License
#
# Copyright (c) 2025, Bjoern Hendrik Fock
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# pylint: disable=invalid-name
# pylint: disable=too-many-lines
#
"""
git-cl: Manage changelists within a Git working directory.

Repository: https://github.com/BHFock/git-cl
Note: This project may or may not be actively maintained in the future.

This CLI tool allows you to group files into named changelists before staging
or committing. Changelists are saved in a 'cl.json' file inside the Git
directory. You can then operate on changelists as logical groups: staging,
committing, listing, or deleting them.

Features:
- Add/remove files to/from changelists
- Stage or commit all files in a changelist
- Show status grouped by changelists
- Delete changelists when done

This tool is intended for use within Git repositories.
"""

__version__ = "0.2.6"

import argparse
import json
import sys
import os
import subprocess
import fcntl
import datetime
from typing import Optional
from pathlib import Path
from contextlib import contextmanager

# Try to import colorama for colored output
try:
    from colorama import Fore, Style
    COLORAMA_AVAILABLE = True
except ImportError:
    COLORAMA_AVAILABLE = False

    # Define dummy objects to avoid NameError
    # pylint: disable=too-few-public-methods
    class _DummyColorama:
        CYAN = ""
        GREEN = ""
        YELLOW = ""
        MAGENTA = ""
        RESET_ALL = ""

    Fore = _DummyColorama()
    Style = _DummyColorama()

# =============================================================================
# INTERNAL UTILITIES
# =============================================================================


@contextmanager
def clutil_file_lock(lock_path: Path):
    """
    Acquires an exclusive lock on a file for safe concurrent access.

    Args:
        lock_path (Path): Path to the lock file.

    Yields:
        None
    """
    with open(lock_path, 'w', encoding='utf-8') as lock_file:
        fcntl.flock(lock_file, fcntl.LOCK_EX)
        try:
            yield
        finally:
            fcntl.flock(lock_file, fcntl.LOCK_UN)


def clutil_should_use_color(args) -> bool:
    """
    Determines whether coloured output should be used in CLI display.

    This function checks multiple conditions to decide if colour formatting
    is appropriate:
    - The --no-color flag is not set.
    - The NO_COLOR environment variable is not set.
    - The output is being sent to a terminal (TTY).
    - The 'colorama' module is available.

    Args:
        args (argparse.Namespace): Parsed command-line arguments, expected to
                                   include the 'no_color' attribute.

    Returns:
        bool: True if coloured output should be enabled, False otherwise.
    """
    no_color_env = bool(os.environ.get('NO_COLOR'))
    is_tty = sys.stdout.isatty()
    return (not (args.no_color or no_color_env or not is_tty) and
            COLORAMA_AVAILABLE)


def clutil_resolve_commit_message(args: argparse.Namespace) -> Optional[str]:
    """
    Resolves the commit message from CLI arguments.

    Args:
        args (argparse.Namespace): Parsed arguments with 'message' or 'file'.

    Returns:
        Optional[str]: The commit message, or None if resolution fails.
    """
    if args.message:
        return args.message

    if args.file:
        try:
            return clutil_read_commit_message_file(args.file)
        except (OSError, ValueError) as error:
            print(f"Error reading commit message file '{args.file}': {error}")
            return None

    print("Error: No commit message provided.")
    return None


def clutil_get_file() -> Path:
    """
    Returns the path to the changelist file inside the Git directory.

    Returns:
        Path: Path to the '.git/cl.json' file.

    Raises:
        SystemExit: If not inside a Git repository.
    """
    try:
        git_dir = subprocess.check_output(
            ["git", "rev-parse", "--git-dir"],
            stderr=subprocess.DEVNULL,
            text=True
        ).strip()
        return Path(git_dir) / "cl.json"
    except subprocess.CalledProcessError:
        print("Error: Not inside a Git repository.")
        print("Please run this command from within a Git repository.")
        sys.exit(1)


def clutil_load() -> dict[str, list[str]]:
    """
    Loads changelist data from the 'cl.json' file.

    Returns:
        dict: A mapping of changelist names to lists of file paths.
    """
    cl_file = clutil_get_file()
    lock_file = cl_file.with_suffix('.lock')
    if cl_file.exists():
        with clutil_file_lock(lock_file):
            try:
                with open(cl_file, "r", encoding="utf-8") as file_handle:
                    return json.load(file_handle)
            except (json.JSONDecodeError, OSError) as error:
                print(f"Error reading changelists: {error}")
                return {}
    return {}


def clutil_save(data: dict[str, list[str]]) -> None:
    """
    Saves the changelist data to 'cl.json', omitting empty changelists.

    Args:
        data (dict): Mapping of changelist names to lists of files.
    """
    cl_file = clutil_get_file()
    lock_file = cl_file.with_suffix('.lock')
    cleaned = {k: v for k, v in data.items() if v}
    with clutil_file_lock(lock_file):
        try:
            with open(cl_file, "w", encoding="utf-8") as file_handle:
                json.dump(cleaned, file_handle, indent=2)
        except OSError as error:
            print(f"Error saving changelists: {error}")


def clutil_validate_name(name: str) -> bool:
    """
    Validates that a changelist name is safe to use.

    Args:
        name (str): The changelist name to validate.

    Returns:
        bool: True if the name is valid, False otherwise.
    """
    # Check for empty names
    if not name:
        return False

    # Check for reasonable length (max 100 characters)
    if len(name) > 100:
        return False

    # Only allow safe characters: letters, numbers, hyphens, underscores, dots
    allowed_chars = set(
        'abcdefghijklmnopqrstuvwxyz'
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        '0123456789-_.'
    )

    if not all(char in allowed_chars for char in name):
        return False

    # Don't allow names that are only dots (filesystem issues)
    if all(char == '.' for char in name):
        return False

    # Check for Git reserved words (only the critical ones)
    reserved_names = {'HEAD', 'FETCH_HEAD', 'ORIG_HEAD', 'MERGE_HEAD',
                      'CHERRY_PICK_HEAD', 'index'}
    if name in reserved_names:
        return False

    return True


def clutil_get_git_root() -> Path:
    """
    Returns the absolute path to the root of the current Git repository.

    Returns:
        Path: The top-level directory of the Git repository.

    Raises:
        SystemExit: If the current directory is not inside a Git repository.
    """
    try:
        return Path(
            subprocess.check_output(
                ["git", "rev-parse", "--show-toplevel"],
                text=True
            ).strip()
        ).resolve()
    except subprocess.CalledProcessError as error:
        print(f"Error: Not inside a Git repository. {error}")
        sys.exit(1)


def clutil_get_git_status(include_untracked: bool = False) -> list[str]:
    """
    Returns the output of 'git status --porcelain' as a list of lines.

    Args:
        include_untracked (bool): If True, includes untracked files using
                                  '--untracked-files=all'.

    Returns:
        list[str]: Each line represents a file's status.

    Raises:
        SystemExit: If the git command fails.
    """
    cmd = ["git", "status", "--porcelain"]
    if include_untracked:
        cmd.append("--untracked-files=all")

    try:
        return subprocess.check_output(cmd, text=True).splitlines()
    except subprocess.CalledProcessError as error:
        print(f"Error getting git status: {error}")
        sys.exit(1)


def clutil_sanitize_path(file_path: str, git_root: Path) -> Optional[str]:
    """
    Sanitizes and validates a file path for safe use with Git commands.

    Args:
        file_path (str): The file path to sanitize
        git_root (Path): The root directory of the Git repository

    Returns:
        str | None: The sanitized path relative to git_root, or None if invalid
    """
    try:
        # Convert to Path object and resolve any relative components
        path = Path(file_path)

        # If it's relative, make it relative to current working directory
        if not path.is_absolute():
            path = Path.cwd() / path

        # Resolve any .. or . components and get absolute path
        path = path.resolve()

        # Ensure the path is within the Git repository
        try:
            relative_path = path.relative_to(git_root)
        except ValueError:
            # Path is outside the Git repository
            return None

        # Convert back to string using forward slashes (Git standard)
        sanitized = relative_path.as_posix()

        # Basic security check: reject paths with dangerous characters
        dangerous_chars = [';', '|', '&', '`', '$', '\n', '\r', '\0']
        if any(char in sanitized for char in dangerous_chars):
            return None

        return sanitized

    except (OSError, ValueError, RuntimeError):
        # Any path resolution errors
        return None


def clutil_get_file_status_map(show_all: bool = False) -> dict[str, str]:
    """
    Get a mapping of files to their Git 2-letter status codes.

    By default, only a predefined set of common status codes are included.
    Files with uncommon status codes (e.g. merge conflicts, type changes)
    are skipped and counted for a warning message — unless `--all` is used.

    Ignored files (status code '! ') are silently excluded from both the
    output and the warning, since `git status --porcelain` does not include
    them unless explicitly requested with `--ignored`.

    Args:
        show_all (bool): If True, include all files regardless of status code.

    Returns:
        dict[str, str]: Mapping of relative file paths
                        to their Git status codes.
    """
    git_root = clutil_get_git_root()
    output = clutil_get_git_status(include_untracked=True)

    # Allowlist of known meaningful status codes
    INTERESTING_CODES = {
        '??', ' M', 'M ', 'MM', 'A ', 'AM', ' D', 'D ', 'R ', 'RM'
    }

    status_map = {}
    skipped = {}

    for line in output:
        if len(line) < 4:
            continue  # malformed line, ignore
        code = line[:2]
        raw_path = line[3:].strip()

        # Handle renamed files
        if code.startswith('R') and '->' in raw_path:
            raw_path = raw_path.split('->')[-1].strip()

        abs_path = (git_root / raw_path).resolve()
        try:
            rel_path = abs_path.relative_to(git_root).as_posix()
        except ValueError:
            rel_path = raw_path

        if show_all or code in INTERESTING_CODES:
            status_map[rel_path] = code
        else:
            skipped.setdefault(code, []).append(rel_path)

    if skipped and not show_all:
        skipped_count = sum(len(v) for v in skipped.values())
        print(f"Note: {skipped_count} file(s) with uncommon Git status codes "
              "were not shown. Use 'git cl st --all' to include them.")

    return status_map


def clutil_format_file_status(
        file: str, status_map: dict[str, str], git_root: Path,
        use_color: bool = True) -> str:
    """
    Format a file's Git status line with optional color-coded output.
    Paths are shown relative to the current working directory.
    """
    abs_file = (git_root / file).resolve()
    rel_to_cwd = os.path.relpath(abs_file, Path.cwd())

    rel_to_git_root = abs_file.relative_to(git_root).as_posix()
    status = status_map.get(rel_to_git_root, "  ")
    tag = f"[{status}]"

    if not use_color or not COLORAMA_AVAILABLE:
        return f"  {tag} {rel_to_cwd}"

    staged, unstaged = status[0], status[1]

    if status == "??":
        color = Fore.BLUE
    elif staged == 'A':
        color = Fore.GREEN
    elif staged != " " and unstaged == " ":
        color = Fore.GREEN
    elif staged == " " and unstaged != " ":
        color = Fore.RED
    elif staged != " " and unstaged != " ":
        color = Fore.MAGENTA
    else:
        color = Style.RESET_ALL

    return f"{color}  {tag} {rel_to_cwd}{Style.RESET_ALL}"


def clutil_read_commit_message_file(file_path: str) -> str:
    """
    Reads a commit message from a file, with validation and processing.

    Args:
        file_path (str): Path to the file containing the commit message

    Returns:
        str: The commit message content

    Raises:
        OSError: If the file cannot be read
        ValueError: If the file is empty or contains only whitespace
    """
    try:
        # Resolve path relative to current working directory
        path = Path(file_path).resolve()

        # Basic security check - ensure file exists and is readable
        if not path.exists():
            raise OSError(f"File does not exist: {file_path}")

        if not path.is_file():
            raise OSError(f"Path is not a file: {file_path}")

        # Reasonable size limit for commit messages (generous 64KB)
        if path.stat().st_size > 64 * 1024:
            raise ValueError("Commit message file too large (>64KB)")

        # Read the file
        with open(path, 'r', encoding='utf-8') as f:
            content = f.read(64 * 1024)  # Enforce the same limit

    except (OSError, UnicodeDecodeError) as error:
        raise OSError(f"Cannot read file: {error}") from error

    # Validate content
    if not content or not content.strip():
        raise ValueError(
            "Commit message file is empty or contains only whitespace")

    # Process the content similar to how Git does it:
    # - Strip trailing whitespace from each line
    # - Remove trailing empty lines
    lines = [line.rstrip() for line in content.splitlines()]

    # Remove trailing empty lines
    while lines and not lines[-1]:
        lines.pop()

    if not lines:
        raise ValueError(
            "Commit message file contains no content after processing")

    # Join lines back together
    processed_content = '\n'.join(lines)

    return processed_content


def clutil_is_file_untracked(
        file_path_rel_to_git_root: str, git_root: Path) -> bool:
    """
    Check if a file (specified relative to git root) is untracked.

    Args:
        file_path_rel_to_git_root: File path relative to git repository root
        git_root: Absolute path to git repository root

    Returns:
        True if the file is untracked, False if it's tracked
    """
    # Get git status output
    output = clutil_get_git_status(include_untracked=True)

    # Get absolute path of the file we're checking
    abs_file_path = (git_root / file_path_rel_to_git_root).resolve()

    # Check untracked files and directories
    for line in output:
        if line.startswith("??"):
            raw_path = line[3:].strip()
            abs_untracked = (git_root / raw_path).resolve()

            # Direct match for files
            if abs_file_path == abs_untracked:
                return True

            # Check if file is under an untracked directory
            if (
                abs_untracked.is_dir()
                and abs_file_path.is_relative_to(abs_untracked)
            ):
                return True

    return False


def clutil_get_stash_file() -> Path:
    """
    Returns the path to the stash metadata file inside the Git directory.

    Returns:
        Path: Path to the '.git/cl-stashes.json' file.
    """
    git_dir = Path(subprocess.check_output(
        ["git", "rev-parse", "--git-dir"],
        stderr=subprocess.DEVNULL,
        text=True
    ).strip())
    return git_dir / "cl-stashes.json"


def clutil_load_stashes() -> dict[str, dict]:
    """
    Loads stash metadata from the 'cl-stashes.json' file.

    Returns:
        dict: A mapping of stashed changelist names to their metadata.
    """
    stash_file = clutil_get_stash_file()
    lock_file = stash_file.with_suffix('.lock')
    if stash_file.exists():
        with clutil_file_lock(lock_file):
            try:
                with open(stash_file, "r", encoding="utf-8") as file_handle:
                    return json.load(file_handle)
            except (json.JSONDecodeError, OSError) as error:
                print(f"Error reading stash metadata: {error}")
                return {}
    return {}


def clutil_save_stashes(data: dict[str, dict]) -> None:
    """
    Saves the stash metadata to 'cl-stashes.json'.

    Args:
        data (dict): Mapping of stashed changelist names to metadata.
    """
    stash_file = clutil_get_stash_file()
    lock_file = stash_file.with_suffix('.lock')
    with clutil_file_lock(lock_file):
        try:
            with open(stash_file, "w", encoding="utf-8") as file_handle:
                json.dump(data, file_handle, indent=2)
        except OSError as error:
            print(f"Error saving stash metadata: {error}")


def clutil_check_files_unstaged(files: list[str], git_root: Path) -> tuple[list[str], list[str]]:
    """
    Check which files in the list have staged vs unstaged changes.

    Args:
        files: List of file paths relative to git root
        git_root: Path to git repository root

    Returns:
        tuple: (unstaged_files, staged_files) - files that can/cannot be stashed
    """
    status_map = clutil_get_file_status_map(show_all=True)

    unstaged_files = []
    staged_files = []

    for file_path in files:
        abs_path = (git_root / file_path).resolve()
        if not abs_path.exists():
            continue

        rel_to_git_root = abs_path.relative_to(git_root).as_posix()
        status = status_map.get(rel_to_git_root, "  ")

        # Check if file has staged changes (first character is not space)
        if status[0] != " ":
            staged_files.append(file_path)
        else:
            unstaged_files.append(file_path)

    return unstaged_files, staged_files


def clutil_check_unstash_conflicts_optimized(files: list[str], git_root: Path) -> tuple[list[str], dict[str, str]]:
    """
    Check for conflicts optimized for the stash-branch-unstash workflow.
    
    In the intended workflow:
    1. Stash changelists → clean working directory
    2. Create/switch to feature branch  
    3. Unstash specific changelist → should be conflict-free
    
    This function focuses on detecting only the conflicts that actually matter
    in this workflow, rather than being overly conservative.
    
    Args:
        files: List of file paths relative to git root that were stashed
        git_root: Path to git repository root
        
    Returns:
        tuple: (real_conflicts, file_status_info) where:
        - real_conflicts: Files that will actually prevent unstashing
        - file_status_info: Dict of file -> status description for user info
    """
    status_map = clutil_get_file_status_map(show_all=True)
    real_conflicts = []
    file_status_info = {}
    
    for file_path in files:
        abs_path = (git_root / file_path).resolve()
        
        if not abs_path.exists():
            # File doesn't exist - this is actually GOOD for unstashing
            # The stash will restore it without conflict
            file_status_info[file_path] = "missing (will be restored)"
            continue
            
        rel_to_git_root = abs_path.relative_to(git_root).as_posix()
        status = status_map.get(rel_to_git_root, "  ")
        
        # Analyze what would actually prevent unstashing
        staged, unstaged = status[0], status[1]
        
        if status == "??":
            # Untracked file exists where stash wants to restore a file
            # This is a real conflict - git stash pop will fail
            real_conflicts.append(file_path)
            file_status_info[file_path] = "untracked file blocking stash restoration"
            
        elif unstaged in ['M', 'D']:
            # Working directory modifications that would conflict with stash pop
            real_conflicts.append(file_path)
            if unstaged == 'M':
                file_status_info[file_path] = "modified in working directory"
            else:  # 'D'
                file_status_info[file_path] = "deleted in working directory"
                
        elif staged in ['A', 'M', 'D', 'R']:
            # Staged changes - these usually don't conflict with stash pop
            # but we should inform the user
            if staged == 'A':
                file_status_info[file_path] = "staged for addition (safe)"
            elif staged == 'M':
                file_status_info[file_path] = "staged modifications (safe)"
            elif staged == 'D':
                file_status_info[file_path] = "staged for deletion (safe)"
            elif staged == 'R':
                file_status_info[file_path] = "staged rename (safe)"
                
        else:
            # File is clean - perfect for unstashing
            file_status_info[file_path] = "clean (ready for unstash)"
    
    return real_conflicts, file_status_info


def clutil_suggest_workflow_actions(conflicting_files: list[str], file_status_info: dict[str, str]) -> None:
    """
    Provide workflow-specific suggestions for resolving conflicts.
    
    Args:
        conflicting_files: Files that have real conflicts
        file_status_info: Status information for all files
    """
    if not conflicting_files:
        return
        
    print("Workflow suggestions to resolve conflicts:")
    
    untracked_conflicts = []
    modified_conflicts = []
    deleted_conflicts = []
    
    for file_path in conflicting_files:
        status_desc = file_status_info[file_path]
        if "untracked" in status_desc:
            untracked_conflicts.append(file_path)
        elif "modified in working" in status_desc:
            modified_conflicts.append(file_path)
        elif "deleted in working" in status_desc:
            deleted_conflicts.append(file_path)
    
    if untracked_conflicts:
        print(f"\n  Untracked files blocking stash restoration:")
        for file_path in untracked_conflicts:
            print(f"    {file_path}")
        print(f"  → Solution: Move, rename, or delete these untracked files")
        
    if modified_conflicts:
        print(f"\n  Working directory modifications:")
        for file_path in modified_conflicts:
            print(f"    {file_path}")
        print(f"  → Solution: Stage/commit these changes or revert them")
        print(f"    git add {' '.join(modified_conflicts)} && git commit -m 'Save current work'")
        print(f"    # OR: git checkout -- {' '.join(modified_conflicts)}")
        
    if deleted_conflicts:
        print(f"\n  Files deleted in working directory:")
        for file_path in deleted_conflicts:
            print(f"    {file_path}")
        print(f"  → Solution: If intentional, stage the deletions; if not, restore the files")
        print(f"    git rm {' '.join(deleted_conflicts)} && git commit -m 'Remove files'")
        print(f"    # OR: git checkout HEAD -- {' '.join(deleted_conflicts)}")


def clutil_get_current_branch() -> Optional[str]:
    """
    Get the name of the current Git branch.
    
    Returns:
        Branch name or None if not on a branch (detached HEAD)
    """
    try:
        result = subprocess.run(["git", "branch", "--show-current"], 
                              capture_output=True, text=True, check=True)
        branch = result.stdout.strip()
        return branch if branch else None
    except subprocess.CalledProcessError:
        return None


def clutil_get_stash_source_branch(stash_data: dict) -> Optional[str]:
    """
    Extract the branch name from stash metadata if stored.
    
    Args:
        stash_data: Stash metadata dictionary
        
    Returns:
        Branch name or None if not available
    """
    return stash_data.get('source_branch')


def clutil_find_stash_by_message(message: str) -> Optional[str]:
    """
    Find a stash reference by its commit message.

    Args:
        message: The stash message to search for

    Returns:
        The stash reference (e.g. "stash@{0}") or None if not found
    """
    try:
        stash_list = subprocess.check_output(["git", "stash", "list"], text=True)
        for line in stash_list.strip().split('\n'):
            if line and message in line:
                return line.split(':')[0]
    except subprocess.CalledProcessError:
        pass
    return None


def clutil_create_unique_stash_message(changelist_name: str) -> str:
    """
    Create a unique stash message that includes changelist name and timestamp.
    This helps identify our stashes even when mixed with user-created stashes.

    Args:
        changelist_name: Name of the changelist being stashed

    Returns:
        Unique stash message string
    """
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    return f"git-cl-stash:{changelist_name}:{timestamp}"


def clutil_parse_stash_message(stash_message: str) -> Optional[tuple[str, str]]:
    """
    Parse our stash message format to extract changelist name and timestamp.

    Args:
        stash_message: The stash message to parse

    Returns:
        Tuple of (changelist_name, timestamp) or None if not our format
    """
    if stash_message.startswith("git-cl-stash:"):
        try:
            parts = stash_message.split(":")
            if len(parts) >= 3:
                changelist_name = parts[1]
                timestamp = parts[2]
                return changelist_name, timestamp
        except (IndexError, ValueError):
            pass
    return None


def clutil_find_stash_by_message_substring(message_substring: str) -> Optional[str]:
    """
    Find a stash reference by searching for a substring in stash messages.

    Args:
        message_substring: Part of the stash message to search for

    Returns:
        The stash reference (e.g. "stash@{2}") or None if not found
    """
    try:
        stash_list = subprocess.check_output(["git", "stash", "list"], text=True)
        for line in stash_list.strip().split('\n'):
            if line and message_substring in line:
                # Extract stash reference from format: "stash@{0}: WIP on main: abc1234 message"
                stash_ref = line.split(':')[0].strip()
                return stash_ref
    except subprocess.CalledProcessError:
        pass
    return None


def clutil_rollback_stash(stash_ref: str, changelist_name: str) -> bool:
    """
    Attempt to rollback a stash creation by dropping the stash.

    Args:
        stash_ref: The stash reference to drop (e.g. "stash@{0}")
        changelist_name: Name of changelist for error reporting

    Returns:
        True if rollback succeeded, False otherwise
    """
    try:
        # Attempt to drop the stash
        subprocess.run(["git", "stash", "drop", stash_ref],
                      check=True, capture_output=True, text=True)
        print(f"Rolled back stash {stash_ref} due to metadata save failure.")
        return True
    except subprocess.CalledProcessError as error:
        print(f"Warning: Could not rollback stash {stash_ref}: {error}")
        print(f"You may need to manually clean up stash for changelist '{changelist_name}'")
        return False


# =============================================================================
# CLI COMMANDS
# =============================================================================


def cl_add(args: argparse.Namespace) -> None:
    """
    Adds one or more files to the specified changelist, creating it if needed.
    Prevents adding files that are in stashed changelists.
    """
    if not clutil_validate_name(args.name):
        print(
            f"Error: Invalid changelist name '{args.name}'. Names cannot "
            "contain special characters or be Git reserved words.")
        return

    changelists = clutil_load()
    stashes = clutil_load_stashes()
    git_root = clutil_get_git_root()

    files = []
    for file in args.files:
        sanitized = clutil_sanitize_path(file, git_root)
        if sanitized:
            files.append(sanitized)
        else:
            print(f"Warning: Skipping invalid or unsafe path: '{file}'")

    # Check if any files are in stashed changelists
    blocked_files = []
    for file_path in files:
        for stash_name, stash_data in stashes.items():
            if file_path in stash_data['files']:
                blocked_files.append((file_path, stash_name))

    if blocked_files:
        print("Error: Cannot add files that are in stashed changelists:")
        for file_path, stash_name in blocked_files:
            print(f"  {file_path} (in stashed changelist '{stash_name}')")
        print("Unstash the changelist first if you want to modify it.")
        return

    if args.name not in changelists:
        changelists[args.name] = []

    for file in files:
        # Remove from other active changelists
        for clist in changelists.values():
            if file in clist:
                clist.remove(file)
        if file not in changelists[args.name]:
            changelists[args.name].append(file)

    clutil_save(changelists)
    print(f"Added to '{args.name}': {files}")


def cl_stage(args: argparse.Namespace) -> None:
    """
    Stages all tracked files in the given changelist and optionally
    deletes the changelist.

    Args:
        args: argparse.Namespace with 'name' and 'delete' attributes.
    """
    changelists = clutil_load()
    name = args.name
    if name not in changelists:
        print(f"Changelist '{name}' not found.")
        return

    git_root = clutil_get_git_root()
    to_stage = []

    for stored_path in changelists[name]:
        # Convert stored path (relative to git root) to absolute path
        abs_path = (git_root / stored_path).resolve()

        if not abs_path.exists():
            print(f"Warning: '{stored_path}' does not exist.")
            continue

        # Convert to path relative to current working directory for Git command
        rel_to_cwd = os.path.relpath(abs_path, Path.cwd())

        # Check if this file is tracked (not untracked)
        if not clutil_is_file_untracked(stored_path, git_root):
            to_stage.append(rel_to_cwd)

    if not to_stage:
        print(f"No tracked files to stage in changelist '{name}'.")
        return

    try:
        subprocess.run(["git", "add", "--"] + to_stage, check=True)
        print(f"Staged tracked files from changelist '{name}':")
        for file in to_stage:
            print(f"  {file}")
    except subprocess.CalledProcessError as error:
        print(f"Error staging files: {error}")
        return

    # Only delete if --delete flag is set
    if args.delete:
        del changelists[name]
        clutil_save(changelists)
        print(f"Deleted changelist '{name}'")


def cl_unstage(args: argparse.Namespace) -> None:
    """
    Unstages all staged files in the specified changelist, moving them back
    to the working directory as unstaged changes.

    Args:
        args: argparse.Namespace with 'name' and 'keep' attributes.
    """
    changelists = clutil_load()
    name = args.name
    if name not in changelists:
        print(f"Changelist '{name}' not found.")
        return

    git_root = clutil_get_git_root()
    to_unstage = []

    # Get current status to identify staged files
    status_map = clutil_get_file_status_map(show_all=True)

    for stored_path in changelists[name]:
        # Convert stored path (relative to git root) to absolute path
        abs_path = (git_root / stored_path).resolve()

        if not abs_path.exists():
            print(f"Warning: '{stored_path}' does not exist.")
            continue

        # Convert to path relative to current working directory for Git command
        rel_to_cwd = os.path.relpath(abs_path, Path.cwd())

        # Check if this file has staged changes
        rel_to_git_root = abs_path.relative_to(git_root).as_posix()
        status = status_map.get(rel_to_git_root, "  ")

        # File has staged changes if first character is not space
        if status[0] != " ":
            to_unstage.append(rel_to_cwd)

    if not to_unstage:
        print(f"No staged files to unstage in changelist '{name}'.")
        return

    try:
        # Use git reset HEAD to unstage files
        subprocess.run(["git", "reset", "HEAD", "--"] + to_unstage, check=True)
        print(f"Unstaged files from changelist '{name}':")
        for file in to_unstage:
            print(f"  {file}")
    except subprocess.CalledProcessError as error:
        print(f"Error unstaging files: {error}")
        return

    # Only delete if --delete flag is set
    if args.delete:
        del changelists[name]
        clutil_save(changelists)
        print(f"Deleted changelist '{name}'")


def cl_status(args: argparse.Namespace) -> None:
    """
    Displays git status grouped by changelist membership, including stashed changelists.

    Shows active changelists first, then a separate "Stashed Changelists" section,
    then unassigned files. Filtering by changelist names applies only to active
    changelists unless --include-no-cl is specified.
    """
    selected_names = set(args.names) if args.names else None
    changelists = clutil_load()
    stashes = clutil_load_stashes()
    git_root = clutil_get_git_root()
    st_map = clutil_get_file_status_map(show_all=args.all)

    use_color = clutil_should_use_color(args)

    assigned_files = set()
    shown_any_active = False

    # Show active changelists first
    for cl_name, files in changelists.items():
        # Skip any remaining stashed entries (cleanup from old implementation)
        if cl_name.endswith('_stashed'):
            continue

        if selected_names is not None and cl_name not in selected_names:
            continue

        if files:  # Only show non-empty changelists
            print(f"{cl_name}:")
            shown_any_active = True
            for file in files:
                print(clutil_format_file_status(file, st_map, git_root, use_color))

            # Track assigned files
            for f in files:
                try:
                    abs_path = (git_root / f).resolve()
                    rel_path = abs_path.relative_to(git_root).as_posix()
                    assigned_files.add(rel_path)
                except (ValueError, OSError) as error:
                    print(f"Error resolving path: {error}")

    # Show stashed changelists section
    if stashes and (selected_names is None):  # Only show when not filtering
        if shown_any_active:
            print()  # Add spacing
        print("Stashed Changelists:")

        # Sort by timestamp (most recent first)
        stashed_items = []
        for stash_name, stash_data in stashes.items():
            timestamp = stash_data.get('timestamp', '')
            file_count = len(stash_data.get('files', []))
            stashed_items.append((stash_name, file_count, timestamp))

        # Sort by timestamp descending (most recent first)
        stashed_items.sort(key=lambda x: x[2], reverse=True)

        for stash_name, file_count, timestamp in stashed_items:
            # Format timestamp for display
            try:
                dt = datetime.datetime.fromisoformat(timestamp)
                formatted_time = dt.strftime("%Y-%m-%d %H:%M")
            except (ValueError, AttributeError):
                formatted_time = "unknown time"

            file_word = "file" if file_count == 1 else "files"
            print(f"  {stash_name} ({file_count} {file_word}, {formatted_time})")

    # Show unassigned files
    if selected_names is None or args.include_no_cl:
        no_cl_files = [file for file in st_map if file not in assigned_files]
        if no_cl_files:
            if shown_any_active or stashes:
                print()  # Add spacing
            print("No Changelist:")
            for file in sorted(no_cl_files):
                print(clutil_format_file_status(file, st_map, git_root, use_color))

    # Clean up any old-style stashed entries from changelists
    old_stashed_entries = [name for name in changelists.keys() if name.endswith('_stashed')]
    if old_stashed_entries:
        for old_name in old_stashed_entries:
            del changelists[old_name]
        clutil_save(changelists)
        print(f"\nCleaned up {len(old_stashed_entries)} old stashed changelist entries.")


def cl_diff(args: argparse.Namespace) -> None:
    """
    Show git diff for one or more changelists.

    By default, shows unstaged changes (like `git diff`).
    Use --staged for staged changes, or --both to show both.

    Args:
        args: argparse.Namespace with 'names' list of changelists,
              and optional 'staged' and 'both' flags
    """
    changelists = clutil_load()
    git_root = clutil_get_git_root()
    diff_files = set()

    for name in args.names:
        if name not in changelists:
            print(f"Changelist '{name}' not found.")
            continue
        for path in changelists[name]:
            abs_path = (git_root / path).resolve()
            if abs_path.exists():
                rel_to_cwd = os.path.relpath(abs_path, Path.cwd())
                diff_files.add(rel_to_cwd)
            else:
                print(f"Warning: File '{path}' from '{name}' does not exist.")

    if not diff_files:
        print("No valid files to diff.")
        return

    sorted_files = sorted(diff_files)

    try:
        if args.both:
            # Show both unstaged and staged diffs
            print("=== Unstaged changes (working tree vs index) ===")
            subprocess.run(["git", "diff", "--"] + sorted_files, check=False)
            print("\n=== Staged changes (index vs HEAD) ===")
            subprocess.run(["git", "diff", "--staged", "--"] + sorted_files,
                           check=False)
        elif args.staged:
            # Show only staged changes
            subprocess.run(["git", "diff", "--staged", "--"] + sorted_files,
                           check=False)
        else:
            # Default: show unstaged changes
            subprocess.run(["git", "diff", "--"] + sorted_files, check=False)
    except subprocess.CalledProcessError as error:
        print(f"Error running git diff: {error}")


def cl_remove(args: argparse.Namespace) -> None:
    """
    Removes one or more files from any changelists they are part of.

    Args:
        args: argparse.Namespace with 'files' attribute.
    """
    changelists = clutil_load()
    removed = []

    git_root = clutil_get_git_root()
    for file in args.files:
        sanitized = clutil_sanitize_path(file, git_root)
        if sanitized is None:
            print(f"Warning: Skipping invalid or unsafe path: '{file}'")
            continue

        found = False
        for name, files in changelists.items():
            if sanitized in files:
                files.remove(sanitized)
                removed.append(sanitized)
                print(f"Removed '{sanitized}' from changelist '{name}'")
                found = True
                break  # Stop after first match

        if not found:
            print(f"'{file}' was not found in any changelist.")

    if removed:
        clutil_save(changelists)


def cl_delete(args: argparse.Namespace) -> None:
    """
    Deletes one or more changelists by name, or all with --all.
    """
    changelists = clutil_load()

    if args.all and args.names:
        print("Error: Cannot specify changelist names and --all together.")
        return

    if args.all:
        if not changelists:
            print("No changelists to delete.")
            return
        count = len(changelists)
        changelists.clear()
        clutil_save(changelists)
        print(f"Deleted all {count} changelists.")
        return

    if not args.names:
        print("Error: No changelist names provided.")
        return

    deleted = False
    for name in args.names:
        if name in changelists:
            del changelists[name]
            print(f"Deleted changelist '{name}'")
            deleted = True
        else:
            print(f"Changelist '{name}' not found.")

    if deleted:
        clutil_save(changelists)


def cl_commit(args: argparse.Namespace) -> None:
    """
    Commits all tracked files in the specified changelist, then optionally
    deletes it.

    Args:
        args: argparse.Namespace with 'name', 'message'/'file',
              and 'keep' attributes.
    """
    changelists = clutil_load()
    name = args.name
    if name not in changelists:
        print(f"Changelist '{name}' not found.")
        return

    git_root = clutil_get_git_root()
    to_commit = []

    for stored_path in changelists[name]:
        # Convert stored path (relative to git root) to absolute path
        abs_path = (git_root / stored_path).resolve()

        if not abs_path.exists():
            print(f"Warning: '{stored_path}' does not exist.")
            continue

        # Convert to path relative to current working directory for Git command
        rel_to_cwd = os.path.relpath(abs_path, Path.cwd())

        # Check if this file is tracked (not untracked)
        if not clutil_is_file_untracked(stored_path, git_root):
            to_commit.append(rel_to_cwd)

    if not to_commit:
        print(f"No tracked files to commit in changelist '{name}'.")
        return

    commit_message = clutil_resolve_commit_message(args)
    if not commit_message:
        return

    try:
        subprocess.run(["git", "commit", "-m", commit_message, "--"]
                       + to_commit, check=True)
        print(f"Committed tracked files from changelist '{name}':")
        for file in to_commit:
            print(f"  {file}")
    except subprocess.CalledProcessError as error:
        print(f"Error committing changelist '{name}': {error}")
        return

    if not args.keep:
        del changelists[name]
        clutil_save(changelists)
        print(f"Deleted changelist '{name}'")
    else:
        print(f"Kept changelist '{name}' (use --keep flag to preserve)")


def cl_stash(args: argparse.Namespace) -> None:
    """
    Stash all unstaged changes for files in the specified changelist.
    Only allows stashing if all files in the changelist are unstaged.
    Uses atomic operations with rollback on failure.

    Args:
        args: argparse.Namespace with 'name' attribute.
    """
    changelists = clutil_load()
    stashes = clutil_load_stashes()
    name = args.name

    # Pre-validation Step 1: Check if changelist exists
    if name not in changelists:
        print(f"Changelist '{name}' not found.")
        return

    # Pre-validation Step 2: Check if changelist is already stashed
    if name in stashes:
        print(f"Changelist '{name}' is already stashed.")
        print(f"Use 'git cl unstash {name}' to restore it first.")
        return

    git_root = clutil_get_git_root()
    files = changelists[name]

    # Pre-validation Step 3: Check if changelist is empty
    if not files:
        print(f"Changelist '{name}' is empty - nothing to stash.")
        return

    # Pre-validation Step 4: Check that all files exist
    missing_files = []
    existing_files = []
    for stored_path in files:
        abs_path = (git_root / stored_path).resolve()
        if not abs_path.exists():
            missing_files.append(stored_path)
        else:
            existing_files.append((stored_path, abs_path))

    if missing_files:
        print(f"Error: Cannot stash changelist '{name}' because these files no longer exist:")
        for file_path in missing_files:
            print(f"  {file_path}")
        print("Remove these files from the changelist first using 'git cl remove'.")
        return

    # Pre-validation Step 5: Check that all files have only unstaged changes
    unstaged_files, staged_files = clutil_check_files_unstaged([f[0] for f in existing_files], git_root)

    if staged_files:
        print(f"Error: Cannot stash changelist '{name}' because these files have staged changes:")
        for file_path in staged_files:
            print(f"  {file_path}")
        print("Please unstage the files first using 'git cl unstage' or commit them separately.")
        return

    # Pre-validation Step 6: Check that ALL files have unstaged changes (stashable)
    status_map = clutil_get_file_status_map(show_all=True)
    files_with_unstaged_changes = []
    files_without_changes = []
    untracked_files = []

    for stored_path, abs_path in existing_files:
        rel_to_git_root = abs_path.relative_to(git_root).as_posix()
        status = status_map.get(rel_to_git_root, "  ")

        if status == "??":
            # Untracked files can't be stashed
            untracked_files.append(stored_path)
        elif status[1] != " ":
            # Second character != space means unstaged changes
            files_with_unstaged_changes.append(stored_path)
        else:
            # Clean files or only staged changes
            files_without_changes.append(stored_path)

    # Report untracked files
    if untracked_files:
        print(f"Error: Cannot stash changelist '{name}' because these files are untracked:")
        for file_path in untracked_files:
            print(f"  {file_path}")
        print("Untracked files cannot be stashed. Add them to git first or remove from changelist.")
        return

    # Report files without unstaged changes
    if files_without_changes:
        print(f"Error: Cannot stash changelist '{name}' because these files have no unstaged changes:")
        for file_path in files_without_changes:
            status = status_map.get((git_root / file_path).resolve().relative_to(git_root).as_posix(), "  ")
            if status == "  ":
                print(f"  {file_path} (clean)")
            else:
                print(f"  {file_path} (only staged changes)")
        print("All files in the changelist must have unstaged changes to be stashed.")
        return

    # All files have unstaged changes - proceed with stashing
    print(f"Stashing all {len(files_with_unstaged_changes)} file(s) from changelist '{name}'...")

    # Convert all file paths to relative-to-cwd for git command
    files_for_git = []
    for stored_path, abs_path in existing_files:
        rel_to_cwd = os.path.relpath(abs_path, Path.cwd())
        files_for_git.append(rel_to_cwd)

    # Create unique stash message
    stash_message = clutil_create_unique_stash_message(name)

    # ATOMIC OPERATION PHASE 1: Create the git stash
    try:
        cmd = ["git", "stash", "push", "-m", stash_message, "--"] + files_for_git
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)

        # This shouldn't happen due to pre-validation, but double-check
        if "No local changes to save" in result.stderr:
            print(f"Unexpected: No changes were stashed for changelist '{name}'.")
            return

    except subprocess.CalledProcessError as error:
        print(f"Error creating stash: {error}")
        if error.stderr:
            print(f"Git error: {error.stderr}")
        return

    # ATOMIC OPERATION PHASE 2: Find the created stash
    stash_ref = clutil_find_stash_by_message_substring(f"git-cl-stash:{name}:")
    if not stash_ref:
        print("Error: Could not locate the created stash.")
        print(f"Look for a stash with message containing 'git-cl-stash:{name}:'")
        # Note: We don't attempt rollback here since we can't find the stash reference
        return

    # ATOMIC OPERATION PHASE 3: Save metadata and update changelists
    # Prepare new metadata first (before any file operations)
    new_stash_metadata = {
        "stash_ref": stash_ref,
        "stash_message": stash_message,
        "files": files.copy(),
        "timestamp": datetime.datetime.now().isoformat()
    }

    # Make a backup of current changelists for potential rollback
    original_changelists = changelists.copy()

    try:
        # Step 3a: Save stash metadata
        stashes[name] = new_stash_metadata
        clutil_save_stashes(stashes)

        # Step 3b: Remove changelist from active changelists
        del changelists[name]
        clutil_save(changelists)

        # Success! All atomic operations completed
        print(f"Successfully stashed changelist '{name}'")
        print(f"Stashed all {len(existing_files)} file(s):")
        for stored_path, _ in existing_files:
            print(f"  {stored_path}")
        print(f"Use 'git cl unstash {name}' to restore the changelist.")

    except Exception as error:
        print(f"Error during atomic operation: {error}")
        print("Attempting to rollback changes...")

        # ROLLBACK PHASE: Attempt to restore consistent state
        rollback_success = True

        # Try to restore stashes metadata (remove the failed entry)
        try:
            if name in stashes:
                del stashes[name]
                clutil_save_stashes(stashes)
                print("Rolled back stash metadata.")
            else:
                print("Stash metadata was not saved, no rollback needed.")
        except Exception as stash_rollback_error:
            print(f"Warning: Could not rollback stash metadata: {stash_rollback_error}")
            rollback_success = False

        # Try to restore original changelists
        try:
            # Restore the original changelists
            clutil_save(original_changelists)
            print("Rolled back changelist modifications.")
        except Exception as changelist_rollback_error:
            print(f"Warning: Could not rollback changelist changes: {changelist_rollback_error}")
            rollback_success = False

        # Try to drop the orphaned stash
        if not clutil_rollback_stash(stash_ref, name):
            rollback_success = False

        if rollback_success:
            print(f"Rollback completed successfully. Changelist '{name}' remains active.")
        else:
            print(f"Partial rollback failure. Manual cleanup may be required:")
            print(f"  - Check 'git stash list' for orphaned stash: {stash_ref}")
            print(f"  - Verify changelist '{name}' state with 'git cl status'")
            print(f"  - Consider 'git stash drop {stash_ref}' if stash is orphaned")

        return


def cl_unstash(args: argparse.Namespace) -> None:
    """
    Restore a stashed changelist to the working directory.

    Args:
        args: argparse.Namespace with 'name' and optional 'force' attributes.
    """
    stashes = clutil_load_stashes()
    changelists = clutil_load()
    name = args.name

    # Handle both "name" and "name_stashed" formats
    if name.endswith("_stashed"):
        base_name = name[:-8]  # Remove "_stashed" suffix
        stash_key = base_name
    else:
        base_name = name
        stash_key = name

    if stash_key not in stashes:
        print(f"No stashed changelist found for '{base_name}'.")
        available = list(stashes.keys())
        if available:
            print("Available stashed changelists:")
            for stashed_name in available:
                print(f"  {stashed_name}")
        return

    stash_data = stashes[stash_key]
    stash_ref = stash_data["stash_ref"]
    files = stash_data["files"]

    # Check if target changelist name already exists
    if base_name in changelists and changelists[base_name]:
        print(f"Error: Changelist '{base_name}' already exists with files.")
        print("Please delete or rename the existing changelist first.")
        return

    git_root = clutil_get_git_root()

    # Check for conflicts unless --force is used
    if not getattr(args, 'force', False):
        modified_files = clutil_check_unstash_conflicts(files, git_root)
        if modified_files:
            print(f"Error: These files have been modified since stashing:")
            for file_path in modified_files:
                print(f"  {file_path}")
            print(f"\nUse 'git cl unstash {base_name} --force' to attempt merge anyway.")
            return

    # Apply the stash
    try:
        # Pop the specific stash
        subprocess.run(["git", "stash", "pop", stash_ref], check=True)

        # Restore the changelist
        changelists[base_name] = files.copy()

        # Remove stashed version if it exists
        stashed_name = f"{base_name}_stashed"
        if stashed_name in changelists:
            del changelists[stashed_name]

        clutil_save(changelists)

        # Remove from stash metadata
        del stashes[stash_key]
        clutil_save_stashes(stashes)

        print(f"Restored changelist '{base_name}' from stash")
        print(f"Restored {len(files)} file(s):")
        for file_path in files:
            print(f"  {file_path}")

    except subprocess.CalledProcessError as error:
        print(f"Error applying stash: {error}")
        print("The stash was not removed. You may need to resolve conflicts manually.")
        print(f"Try: git stash show {stash_ref}")
        print(f"Or: git stash drop {stash_ref}")


def cl_help(args: argparse.Namespace) -> None:
    """
    Displays the main help message using argparse's built-in formatting.
    """
    args.parser.print_help()


def main() -> None:
    """
    Entry point for the git-cl command-line interface.

    Parses command-line arguments and dispatches to the appropriate
    subcommand handler (e.g., add, remove, stage, commit, etc.).
    """
    parser = argparse.ArgumentParser(
        prog='git-cl',
        usage='git cl <command> [<args>]',
        description=(
            "git-cl: A Git subcommand for managing named changelists \n"
            "        Group files into logical changelists before staging "
            "or committing.\n\n"
            "        NOTE: Commit/stage commands only operate on tracked files"
            "\n              untracked files in changelists are safely "
            "ignored."),
        epilog=(
            "Example usage:\n"
            "    git cl add my-feature file1.py file2.py\n"
            "    git cl status\n"
            "    git cl commit my-feature -m 'Implement feature'\n\n"
            "See also: https://github.com/BHFock/git-cl"),
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False)

    parser.add_argument(
        '--version',
        action='version',
        version=f'git-cl {__version__}',
        help=argparse.SUPPRESS)

    subparsers = parser.add_subparsers(dest='command', title='Commands')

    # add
    add_parser = subparsers.add_parser('add', aliases=['a'],
                                       help='Add files to a named changelist',
                                       description=(
                                           "Add one or more files to a named "
                                           "changelist. If the changelist "
                                           "does not exist, it will be "
                                           "created automatically."))
    add_parser.add_argument('name', metavar='CHANGELIST',
                            help='Name of the changelist to add files to')
    add_parser.add_argument('files', metavar='FILE', nargs='+',
                            help=("One or more files to include "
                                  "in the changelist"))
    add_parser.set_defaults(func=cl_add)

    # remove
    remove_parser = subparsers.add_parser('remove', aliases=['r', 'rm'],
                                          help=("Remove files from any "
                                                "changelist"),
                                          description=("Removes files from "
                                                       "any changelists they "
                                                       "belong to."))
    remove_parser.add_argument('files', metavar='FILE', nargs='+',
                               help=("One or more files to remove "
                                     "from changelists"))
    remove_parser.set_defaults(func=cl_remove)

    # delete
    delete_parser = subparsers.add_parser('delete', aliases=['del'],
                                          help=("Delete one or more "
                                                "changelists"),
                                          description=(
                                              "Delete one or more changelists "
                                              "by name, or remove all with "
                                              "--all."))
    delete_parser.add_argument('names', metavar='CHANGELIST', nargs='*',
                               help=("One or more changelists to delete "
                                     "(required unless --all is used)"))
    delete_parser.add_argument('--all', action='store_true',
                               help='Delete all changelists')
    delete_parser.set_defaults(func=cl_delete)

    # status / st
    status_parser = subparsers.add_parser('status', aliases=['s', 'st'],
                                          help=("Show file changes grouped by "
                                                "changelist"),
                                          description=(
                                              "Show file changes grouped by "
                                              "changelist. Unassigned files "
                                              "appear under 'No Changelist'."))
    status_parser.add_argument('names', metavar='CHANGELIST', nargs='*',
                               help=("Optional list of changelists to show "
                                     "(default: all)"))
    status_parser.add_argument('--include-no-cl', action='store_true',
                               help=("When filtering by changelist names, "
                                     "also show files not assigned to any "
                                     "changelist"))
    status_parser.add_argument('--all', action='store_true',
                               help=("Include files with uncommon Git "
                                     "status codes"))
    status_parser.add_argument('--no-color', action='store_true',
                               help='Disable colored output')
    status_parser.set_defaults(func=cl_status)

    # diff
    diff_parser = subparsers.add_parser('diff',
                                        help=("Show git diff for one or more "
                                              "changelists"),
                                        description=(
                                            "Show unified diff for the files "
                                            "in one or more changelists. "
                                            "By default, shows unstaged "
                                            "changes (like `git diff`). "
                                            "Use --staged for staged changes, "
                                            "or --both to show both."))
    diff_parser.add_argument('names', metavar='CHANGELIST', nargs='+',
                             help='One or more changelists to diff')
    diff_parser.add_argument('--staged', action='store_true',
                             help='Show staged changes (index vs HEAD)')
    diff_parser.add_argument('--both', action='store_true',
                             help='Show both unstaged and staged diffs')
    diff_parser.set_defaults(func=cl_diff)

    # stage
    stage_parser = subparsers.add_parser('stage',
                                         help=("Stage tracked files from a "
                                               "changelist"),
                                         description=(
                                             "Stage all tracked files from "
                                             "the specified changelist. Only "
                                             "files already tracked by Git "
                                             "will be staged. Untracked files "
                                             "in the changelist are safely "
                                             "ignored and remain untracked. "
                                             "By default, the changelist is "
                                             "kept unless --delete is used."))
    stage_parser.add_argument('name', metavar='CHANGELIST',
                              help='Name of the changelist to stage')
    stage_parser.add_argument('--delete', action='store_true',
                              help='Delete the changelist after staging')
    stage_parser.set_defaults(func=cl_stage)

    # unstage
    unstage_parser = subparsers.add_parser('unstage',
                                           help=("Unstage tracked files from "
                                                 "a changelist"),
                                           description=(
                                               "Unstage all staged files from "
                                               "the specified changelist, "
                                               "moving them back to unstaged "
                                               "state in the working "
                                               "directory. By default, the "
                                               "changelist is kept unless "
                                               "--delete is used."))
    unstage_parser.add_argument('name', metavar='CHANGELIST',
                                help='Name of the changelist to unstage')
    unstage_parser.add_argument('--delete', action='store_true',
                                help='Delete the changelist after unstaging')
    unstage_parser.set_defaults(func=cl_unstage)

    # commit / ci
    commit_parser = subparsers.add_parser('commit', aliases=['ci'],
                                          help=("Commit tracked files from a "
                                                "changelist (auto-stages, "
                                                "ignores untracked)"),
                                          description=(
                                              "Stage and commit all tracked "
                                              "files from the specified "
                                              "changelist using the provided "
                                              "message. Untracked files in "
                                              "the changelist are ignored and "
                                              "remain untracked. By default, "
                                              "the changelist is deleted "
                                              "after committing unless --keep "
                                              "is used."))
    commit_parser.add_argument('name', metavar='CHANGELIST',
                               help='Name of the changelist to commit')
    msg_group = commit_parser.add_mutually_exclusive_group(required=True)
    msg_group.add_argument('-m', '--message',
                           help='Commit message')
    msg_group.add_argument('-F', '--file',
                           help='Read commit message from file')
    commit_parser.add_argument('--keep', action='store_true',
                               help='Keep the changelist after committing')
    commit_parser.set_defaults(func=cl_commit)

    # stash
    stash_parser = subparsers.add_parser('stash',
                                         help='Stash changes in a changelist',
                                         description=(
                                             "Stash all unstaged changes for files "
                                             "in the specified changelist. Only "
                                             "files with unstaged changes can be "
                                             "stashed. The changelist will be "
                                             "renamed to 'name_stashed' and shown "
                                             "in git cl status."))
    stash_parser.add_argument('name', metavar='CHANGELIST',
                              help='Name of the changelist to stash')
    stash_parser.set_defaults(func=cl_stash)

    # unstash
    unstash_parser = subparsers.add_parser('unstash',
                                           help='Restore a stashed changelist',
                                           description=(
                                               "Restore a previously stashed "
                                               "changelist to the working directory. "
                                               "If any files have been modified since "
                                               "stashing, use --force to attempt "
                                               "automatic merging."))
    unstash_parser.add_argument('name', metavar='CHANGELIST',
                                help=('Name of the changelist to unstash '
                                      '(with or without _stashed suffix)'))
    unstash_parser.add_argument('--force', action='store_true',
                                help='Force unstash even if files have changed')
    unstash_parser.set_defaults(func=cl_unstash)

    # help command
    help_parser = subparsers.add_parser('help',
                                        help='Show this help message',
                                        description=(
                                            "Displays a summary of "
                                            "available git-cl commands."))
    help_parser.set_defaults(func=cl_help, parser=parser)

    args = parser.parse_args()

    # If no command was provided, show help
    if args.command is None:
        parser.print_help()
        return

    # Provide parser to all commands in case needed
    if not hasattr(args, 'parser'):
        args.parser = parser

    args.func(args)


if __name__ == '__main__':
    main()
