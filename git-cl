#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# BSD 3-Clause License
#
# Copyright (c) 2025, Bjoern Hendrik Fock
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
"""
git-cl: Manage changelists within a Git working directory.

This CLI tool allows you to group files into named changelists before staging
or committing. Changelists are saved in a 'cl.json' file inside the Git
directory. You can then operate on changelists as logical groups: staging,
committing, listing, or deleting them.

Features:
- Add/remove files to/from changelists
- Stage or commit all files in a changelist
- Show status grouped by changelists
- Delete changelists when done

This tool is intended for use within Git repositories.
"""

__version__ = "0.1.1"

import argparse
import json
import sys
import subprocess
from pathlib import Path


# =============================================================================
# INTERNAL UTILITIES
# =============================================================================


def clutil_get_file() -> Path:
    """
    Returns the path to the changelist file inside the Git directory.

    Returns:
        Path: Path to the '.git/cl.json' file.

    Raises:
        SystemExit: If not inside a Git repository.
    """
    try:
        git_dir = subprocess.check_output(
            ["git", "rev-parse", "--git-dir"],
            stderr=subprocess.DEVNULL,
            text=True
        ).strip()
        return Path(git_dir) / "cl.json"
    except subprocess.CalledProcessError:
        print("Error: Not inside a Git repository.")
        print("Please run this command from within a Git repository.")
        sys.exit(1)


def clutil_load() -> dict[str, list[str]]:
    """
    Loads changelist data from the 'cl.json' file.

    Returns:
        dict: A mapping of changelist names to lists of file paths.
    """
    cl_file = clutil_get_file()
    if cl_file.exists():
        try:
            with open(cl_file, "r", encoding="utf-8") as file_handle:
                return json.load(file_handle)
        except (json.JSONDecodeError, OSError) as error:
            print(f"Error reading changelists: {error}")
            return {}
    return {}


def clutil_save(data: dict[str, list[str]]) -> None:
    """
    Saves the changelist data to 'cl.json', omitting empty changelists.

    Args:
        data (dict): Mapping of changelist names to lists of files.
    """
    cl_file = clutil_get_file()
    cleaned = {k: v for k, v in data.items() if v}
    try:
        with open(cl_file, "w", encoding="utf-8") as file_handle:
            json.dump(cleaned, file_handle, indent=2)
    except OSError as error:
        print(f"Error saving changelists: {error}")


def clutil_validate_files(files: list[str]) -> list[str]:
    """
    Validates that files exist on disk.

    Args:
        files (list): List of file paths to validate.

    Returns:
        list: List of existing and valid file paths.
    """
    valid = []
    for file in files:
        if Path(file).exists():
            valid.append(file)
        else:
            print(f"Warning: '{file}' does not exist or "
                  "is not tracked by Git.")
    return valid


def clutil_validate_name(name: str) -> bool:
    """
    Validates that a changelist name is safe to use.

    Args:
        name (str): The changelist name to validate.

    Returns:
        bool: True if the name is valid, False otherwise.
    """
    if not name or name.isspace():
        return False
    if name in ['.', '..', 'HEAD', 'master', 'main']:
        return False
    if any(char in name for char in ['/', '\\', ':', '*', '?',
                                     '"', '<', '>', '|']):
        return False
    return True


def clutil_get_git_root() -> Path:
    """
    Returns the absolute path to the root of the current Git repository.

    Returns:
        Path: The top-level directory of the Git repository.

    Raises:
        SystemExit: If the current directory is not inside a Git repository.
    """
    try:
        return Path(
            subprocess.check_output(
                ["git", "rev-parse", "--show-toplevel"],
                text=True
            ).strip()
        ).resolve()
    except subprocess.CalledProcessError as error:
        print(f"Error: Not inside a Git repository. {error}")
        sys.exit(1)


def clutil_get_git_status(include_untracked: bool = False) -> list[str]:
    """
    Returns the output of 'git status --porcelain' as a list of lines.

    Args:
        include_untracked (bool): If True, includes untracked files using
                                  '--untracked-files=all'.

    Returns:
        list[str]: Each line represents a file's status.

    Raises:
        SystemExit: If the git command fails.
    """
    cmd = ["git", "status", "--porcelain"]
    if include_untracked:
        cmd.append("--untracked-files=all")

    try:
        return subprocess.check_output(cmd, text=True).splitlines()
    except subprocess.CalledProcessError as error:
        print(f"Error getting git status: {error}")
        sys.exit(1)


# =============================================================================
# CLI COMMANDS
# =============================================================================


def cl_add(args: argparse.Namespace) -> None:
    """
    Adds one or more files to the specified changelist, creating it if needed.

    Args:
        args: argparse.Namespace with 'name' and 'files' attributes.
    """
    if not clutil_validate_name(args.name):
        print(
            f"Error: Invalid changelist name '{args.name}'. Names cannot "
            "contain special characters or be Git reserved words.")
        return
    changelists = clutil_load()
    files = clutil_validate_files(args.files)
    if args.name not in changelists:
        changelists[args.name] = []
    for file in files:
        for clist in changelists.values():
            if file in clist:
                clist.remove(file)
        if file not in changelists[args.name]:
            changelists[args.name].append(file)
    clutil_save(changelists)
    print(f"Added to '{args.name}': {files}")


def cl_stage(args: argparse.Namespace) -> None:
    """
    Stages all tracked files in the given changelist and
    deletes the changelist.

    Args:
        args: argparse.Namespace with 'name' attribute (changelist name).
    """
    changelists = clutil_load()
    name = args.name
    if name not in changelists:
        print(f"Changelist '{name}' not found.")
        return

    files = changelists[name]
    valid_files = clutil_validate_files(files)

    git_root = clutil_get_git_root()

    valid_paths = {}
    for file in valid_files:
        abs_path = (Path.cwd() / file).resolve()
        valid_paths[abs_path] = file

    output = clutil_get_git_status()

    untracked_files = set()
    untracked_dirs = set()
    for line in output:
        if line.startswith("??"):
            raw_path = line[3:].strip()
            abs_path = (git_root / raw_path).resolve()
            if abs_path.is_dir():
                untracked_dirs.add(abs_path)
            else:
                untracked_files.add(abs_path)

    def is_under_untracked_dirs(path):
        return any(path.is_relative_to(d) for d in untracked_dirs)

    to_stage = []
    for abs_path, orig_path in valid_paths.items():
        if abs_path in untracked_files or is_under_untracked_dirs(abs_path):
            continue
        to_stage.append(orig_path)

    if not to_stage:
        print(f"No tracked files to stage in changelist '{name}'.")
        return

    try:
        subprocess.run(["git", "add", "--"] + to_stage, check=True)
        print(f"Staged tracked files from changelist '{name}':")
        for file in to_stage:
            print(f"  {file}")
    except subprocess.CalledProcessError as error:
        print(f"Error staging files: {error}")
        return

    del changelists[name]
    clutil_save(changelists)
    print(f"Deleted changelist '{name}'")


def cl_list(_args: argparse.Namespace) -> None:
    """
    Lists all changelists and their associated files.

    Args:
        args: argparse.Namespace (not used).
    """
    changelists = clutil_load()
    if not changelists:
        print("No changelists found.")
        return
    for name, files in changelists.items():
        print(f"{name}:")
        for file in files:
            print(f"  {file}")


def cl_status(_args: argparse.Namespace) -> None:
    """
    Displays git status grouped by changelist membership.

    Args:
        args: argparse.Namespace (not used).
    """
    changelists = clutil_load()

    git_root = clutil_get_git_root()

    output = clutil_get_git_status(include_untracked=True)

    status_map = {}
    for line in output:
        code = line[:2]
        raw_path = line[3:].strip()
        abs_path = (git_root / raw_path).resolve()
        rel_path = abs_path.relative_to(git_root).as_posix()

        if code == "??":
            status_map[rel_path] = "??"
        elif code == " D":
            status_map[rel_path] = "D"
        elif code == "D ":
            status_map[rel_path] = "D"
        elif code.strip().startswith("A"):
            status_map[rel_path] = "A"
        elif "M" in code or "T" in code or "R" in code or "C" in code:
            status_map[rel_path] = "M"
        else:
            status_map[rel_path] = " "

    assigned_files = set()
    for files in changelists.values():
        assigned_files.update(files)

    for cl_name, files in changelists.items():
        print(f"{cl_name}:")
        for file in files:
            abs_file = (Path.cwd() / file).resolve()
            try:
                rel_file = abs_file.relative_to(git_root).as_posix()
            except ValueError:
                rel_file = file
            status = status_map.get(rel_file, " ")
            tag = f"[{status}]" if status != " " else "[ ]"
            print(f"  {tag} {file}")

    no_cl_files = [file for file in status_map if file not in assigned_files]
    if no_cl_files:
        print("No Changelist:")
        for file in sorted(no_cl_files):
            status = status_map[file]
            tag = f"[{status}]" if status != " " else "[ ]"
            print(f"  {tag} {file}")


def cl_remove(args: argparse.Namespace) -> None:
    """
    Removes one or more files from any changelists they are part of.

    Args:
        args: argparse.Namespace with 'files' attribute.
    """
    changelists = clutil_load()
    removed = []

    for file in args.files:
        for name, files in changelists.items():
            if file in files:
                files.remove(file)
                removed.append(file)
                print(f"Removed '{file}' from changelist '{name}'")
                break
        else:
            print(f"'{file}' was not found in any changelist.")

    if removed:
        clutil_save(changelists)


def cl_delete(args: argparse.Namespace) -> None:
    """
    Deletes a changelist by name.

    Args:
        args: argparse.Namespace with 'name' attribute.
    """
    changelists = clutil_load()
    if args.name in changelists:
        del changelists[args.name]
        clutil_save(changelists)
        print(f"Deleted changelist '{args.name}'")
    else:
        print(f"Changelist '{args.name}' not found.")


def cl_commit(args: argparse.Namespace) -> None:
    """
    Commits all tracked files in the specified changelist, then deletes it.

    Args:
        args: argparse.Namespace with 'name' and 'message' attributes.
    """
    changelists = clutil_load()
    name = args.name
    if name not in changelists:
        print(f"Changelist '{name}' not found.")
        return

    files = changelists[name]
    valid_files = clutil_validate_files(files)

    git_root = clutil_get_git_root()

    valid_paths = {}
    for file in valid_files:
        abs_path = (Path.cwd() / file).resolve()
        valid_paths[abs_path] = file

    output = clutil_get_git_status()

    untracked_files = set()
    untracked_dirs = set()
    for line in output:
        if line.startswith("??"):
            raw_path = line[3:].strip()
            abs_path = (git_root / raw_path).resolve()
            if abs_path.is_dir():
                untracked_dirs.add(abs_path)
            else:
                untracked_files.add(abs_path)

    def is_under_untracked_dirs(path):
        return any(path.is_relative_to(d) for d in untracked_dirs)

    to_commit = []
    for abs_path, orig_path in valid_paths.items():
        if abs_path in untracked_files or is_under_untracked_dirs(abs_path):
            continue
        to_commit.append(orig_path)

    if not to_commit:
        print(f"No tracked files to commit in changelist '{name}'.")
        return

    try:
        subprocess.run(["git", "add", "--"] + to_commit, check=True)
    except subprocess.CalledProcessError as error:
        print(f"Error staging files for commit: {error}")
        return

    try:
        subprocess.run(["git", "commit", "-m", args.message], check=True)
        print(f"Committed changelist '{name}' with message: {args.message}")
    except subprocess.CalledProcessError as error:
        print(f"Error committing changelist '{name}': {error}")
        return

    del changelists[name]
    clutil_save(changelists)
    print(f"Deleted changelist '{name}'")


def main() -> None:
    """
    Entry point for the git-cl command-line interface.

    Parses command-line arguments and dispatches to the appropriate
    subcommand handler (e.g., add, remove, stage, commit, etc.).
    """
    parser = argparse.ArgumentParser(
        prog='git-cl',
        description=("Manage Git changelists: group related files before "
                     "staging or committing."),
        epilog=(
            "Example usage:\n"
            "  git cl add my-feature file1.py file2.py\n"
            "  git cl status\n"
            "  git cl stage my-feature\n"
            "  git cl commit my-feature -m 'Implement feature'\n"
            "  git cl delete my-feature"
        ),
        formatter_class=argparse.RawTextHelpFormatter
    )

    parser.add_argument(
        '--version',
        action='version',
        version=f'git-cl {__version__}',
        help='Show version and exit'
    )

    subparsers = parser.add_subparsers(dest='command', required=True,
                                       title='Commands')

    # add
    add_parser = subparsers.add_parser(
        'add',
        help='Add files to a named changelist',
        description='Add one or more files to a named changelist. '
                    'If the changelist does not exist, it will be created.'
    )
    add_parser.add_argument('name', metavar='CHANGELIST',
                            help='Name of the changelist')
    add_parser.add_argument('files', metavar='FILE', nargs='+',
                            help='Files to add to the changelist')
    add_parser.set_defaults(func=cl_add)

    # remove
    remove_parser = subparsers.add_parser(
        'remove',
        help='Remove one or more files from their changelists',
        description=("Detaches the specified files from any changelists "
                     "they belong to.")
    )
    remove_parser.add_argument('files', metavar='FILE', nargs='+',
                               help='Files to remove from any changelist')
    remove_parser.set_defaults(func=cl_remove)

    # delete
    delete_parser = subparsers.add_parser(
        'delete',
        help='Delete a changelist by name',
        description=("Deletes the specified changelist and removes its "
                     "file references.")
    )
    delete_parser.add_argument('name', metavar='CHANGELIST',
                               help='Name of the changelist to delete')
    delete_parser.set_defaults(func=cl_delete)

    # list / ls
    list_parser = subparsers.add_parser(
        'list',
        aliases=['ls'],
        help='List all changelists and their files',
        description=("Displays all changelists and the files "
                     "associated with each.")
    )
    list_parser.set_defaults(func=cl_list)

    # status / st
    status_parser = subparsers.add_parser(
        'status',
        aliases=['st'],
        help='Show working tree changes grouped by changelist',
        description=("Displays all file changes grouped by changelist. "
                     "Unassigned changes appear under 'No Changelist'.")
    )
    status_parser.set_defaults(func=cl_status)

    # stage
    stage_parser = subparsers.add_parser(
        'stage',
        help='Stage all tracked files in a changelist and delete it',
        description=("Stages all **tracked** files from the changelist and "
                     "deletes the changelist afterward.")
    )
    stage_parser.add_argument('name', metavar='CHANGELIST',
                              help='Name of the changelist')
    stage_parser.set_defaults(func=cl_stage)

    # commit
    commit_parser = subparsers.add_parser(
        'commit',
        help='Commit all tracked files in a changelist',
        description=("Stages and commits all **tracked** files from the "
                     "changelist using the provided message.")
    )
    commit_parser.add_argument('name', metavar='CHANGELIST',
                               help='Name of the changelist')
    commit_parser.add_argument('-m', '--message', required=True,
                               help='Commit message')
    commit_parser.set_defaults(func=cl_commit)

    args = parser.parse_args()
    args.func(args)


if __name__ == '__main__':
    main()
