#!/usr/bin/env python3
"""
git-cl: Manage changelists within a Git working directory.
"""

import argparse
import json
import sys
import subprocess
from pathlib import Path

def get_git_root():
    try:
        return Path(subprocess.check_output(
            ["git", "rev-parse", "--show-toplevel"],
            text=True
        ).strip()).resolve()
    except subprocess.CalledProcessError:
        print("Error: Not inside a Git repository.")
        sys.exit(1)

def cl_get_file():
    git_dir = subprocess.check_output(["git", "rev-parse", "--git-dir"], text=True).strip()
    return Path(git_dir).resolve() / "cl.json"

def cl_load():
    cl_file = cl_get_file()
    if cl_file.exists():
        with open(cl_file, "r") as f:
            return json.load(f)
    return {}

def cl_save(data):
    cl_file = cl_get_file()
    cleaned = {k: v for k, v in data.items() if v}
    with open(cl_file, "w") as f:
        json.dump(cleaned, f, indent=2)

def cl_validate_files(files):
    git_root = get_git_root()
    valid = []
    for file in files:
        abs_path = (git_root / file).resolve()
        if abs_path.exists():
            valid.append(file)
        else:
            print(f"Warning: '{file}' does not exist or is not tracked by Git.")
    return valid

def cl_add(args):
    changelists = cl_load()
    git_root = get_git_root()
    files = []
    for f in args.files:
        abs_path = (Path(f).resolve())
        try:
            rel_path = abs_path.relative_to(git_root).as_posix()
            files.append(rel_path)
        except ValueError:
            print(f"Warning: '{f}' is outside the Git repository.")
    files = cl_validate_files(files)
    if args.name not in changelists:
        changelists[args.name] = []
    for file in files:
        for cl in changelists.values():
            if file in cl:
                cl.remove(file)
        if file not in changelists[args.name]:
            changelists[args.name].append(file)
    cl_save(changelists)
    print(f"Added to '{args.name}': {files}")

def cl_stage(args):
    changelists = cl_load()
    name = args.name
    if name not in changelists:
        print(f"Changelist '{name}' not found.")
        return
    files = changelists[name]
    git_root = get_git_root()

    valid_files = cl_validate_files(files)
    valid_paths = {}
    for f in valid_files:
        abs_path = (git_root / f).resolve()
        valid_paths[abs_path] = f

    output = subprocess.check_output(["git", "status", "--porcelain"], text=True).splitlines()

    untracked_files = set()
    untracked_dirs = set()
    for line in output:
        if line.startswith("??"):
            raw_path = line[3:].strip()
            abs_path = (git_root / raw_path).resolve()
            if abs_path.is_dir():
                untracked_dirs.add(abs_path)
            else:
                untracked_files.add(abs_path)

    def is_under_untracked_dirs(path):
        for d in untracked_dirs:
            try:
                path.relative_to(d)
                return True
            except ValueError:
                continue
        return False

    to_stage = []
    for abs_path, orig_path in valid_paths.items():
        if abs_path in untracked_files or is_under_untracked_dirs(abs_path):
            continue
        to_stage.append(orig_path)

    if not to_stage:
        print(f"No tracked files to stage in changelist '{name}'.")
    else:
        subprocess.run(["git", "add", "--"] + to_stage, check=True)
        print(f"Staged tracked files from changelist '{name}':")
        for f in to_stage:
            print(f"  {f}")

    del changelists[name]
    cl_save(changelists)
    print(f"Deleted changelist '{name}'")

def cl_list(args):
    changelists = cl_load()
    if not changelists:
        print("No changelists found.")
        return
    for name, files in changelists.items():
        print(f"{name}:")
        for file in files:
            print(f"  {file}")

def cl_status(args):
    changelists = cl_load()
    git_root = get_git_root()

    output = subprocess.check_output(
        ["git", "status", "--porcelain", "--untracked-files=all"], text=True
    ).splitlines()

    status_map = {}
    for line in output:
        code = line[:2]
        raw_path = line[3:].strip()
        abs_path = (git_root / raw_path).resolve()
        rel_path = abs_path.relative_to(git_root).as_posix()
        if code == "??":
            status_map[rel_path] = "??"
        elif code == " D":
            status_map[rel_path] = "D"
        elif code.startswith("A") or "A" in code:
            status_map[rel_path] = "A"
        elif "M" in code or "T" in code or "R" in code or "C" in code:
            status_map[rel_path] = "M"
        else:
            status_map[rel_path] = " "

    assigned_files = set()
    for files in changelists.values():
        assigned_files.update(files)

    for cl_name, files in changelists.items():
        print(f"{cl_name}:")
        for file in files:
            status = status_map.get(file, " ")
            tag = f"[{status}]" if status != " " else "[ ]"
            print(f"  {tag} {file}")

    no_cl_files = []
    for file in status_map.keys():
        if file not in assigned_files:
            no_cl_files.append(file)

    if no_cl_files:
        print("No Changelist:")
        for file in sorted(no_cl_files):
            status = status_map.get(file, " ")
            tag = f"[{status}]" if status != " " else "[ ]"
            print(f"  {tag} {file}")

def cl_remove(args):
    changelists = cl_load()
    git_root = get_git_root()
    removed = []

    for file in args.files:
        abs_path = Path(file).resolve()
        try:
            rel_path = abs_path.relative_to(git_root).as_posix()
        except ValueError:
            print(f"'{file}' is outside the Git repository.")
            continue
        for name, files in changelists.items():
            if rel_path in files:
                files.remove(rel_path)
                removed.append(rel_path)
                print(f"Removed '{rel_path}' from changelist '{name}'")
                break
        else:
            print(f"'{file}' was not found in any changelist.")

    if removed:
        cl_save(changelists)

def cl_delete(args):
    changelists = cl_load()
    if args.name in changelists:
        del changelists[args.name]
        cl_save(changelists)
        print(f"Deleted changelist '{args.name}'")
    else:
        print(f"Changelist '{args.name}' not found.")

def cl_commit(args):
    changelists = cl_load()
    name = args.name
    if name not in changelists:
        print(f"Changelist '{name}' not found.")
        return

    git_root = get_git_root()
    files = changelists[name]
    valid_files = cl_validate_files(files)

    valid_paths = {}
    for f in valid_files:
        abs_path = (git_root / f).resolve()
        valid_paths[abs_path] = f

    output = subprocess.check_output(["git", "status", "--porcelain"], text=True).splitlines()
    untracked_files = set()
    untracked_dirs = set()
    for line in output:
        if line.startswith("??"):
            raw_path = line[3:].strip()
            abs_path = (git_root / raw_path).resolve()
            if abs_path.is_dir():
                untracked_dirs.add(abs_path)
            else:
                untracked_files.add(abs_path)

    def is_under_untracked_dirs(path):
        for d in untracked_dirs:
            try:
                path.relative_to(d)
                return True
            except ValueError:
                continue
        return False

    to_commit = []
    for abs_path, orig_path in valid_paths.items():
        if abs_path in untracked_files or is_under_untracked_dirs(abs_path):
            continue
        to_commit.append(orig_path)

    if not to_commit:
        print(f"No tracked files to commit in changelist '{name}'.")
        return

    subprocess.run(["git", "add", "--"] + to_commit, check=True)
    subprocess.run(["git", "commit", "-m", args.message], check=True)
    print(f"Committed changelist '{name}' with message: {args.message}")

    del changelists[name]
    cl_save(changelists)
    print(f"Deleted changelist '{name}'")

def main():
    parser = argparse.ArgumentParser(
        prog='git-cl',
        description='Organise files into changelists before staging or committing'
    )
    subparsers = parser.add_subparsers(dest='command', required=True)

    add_parser = subparsers.add_parser('add', help='Add files to a changelist')
    add_parser.add_argument('name', help='Name of the changelist')
    add_parser.add_argument('files', nargs='+', help='Files to add')
    add_parser.set_defaults(func=cl_add)

    stage_parser = subparsers.add_parser('stage', help='Stage all files in a changelist and delete it')
    stage_parser.add_argument('name', help='Name of the changelist')
    stage_parser.set_defaults(func=cl_stage)

    list_parser = subparsers.add_parser('list', help='Show all changelists')
    list_parser.set_defaults(func=cl_list)
    subparsers.add_parser('ls', help='Alias for list').set_defaults(func=cl_list)

    status_parser = subparsers.add_parser('status', help='Show changes grouped by changelist')
    status_parser.set_defaults(func=cl_status)
    subparsers.add_parser('st', help='Alias for status').set_defaults(func=cl_status)

    remove_parser = subparsers.add_parser('remove', help='Remove files from their changelists')
    remove_parser.add_argument('files', nargs='+', help='Files to remove')
    remove_parser.set_defaults(func=cl_remove)

    delete_parser = subparsers.add_parser('delete', help='Delete a changelist by name')
    delete_parser.add_argument('name', help='Name of the changelist')
    delete_parser.set_defaults(func=cl_delete)

    commit_parser = subparsers.add_parser('commit', help='Commit all files in a changelist')
    commit_parser.add_argument('name', help='Name of the changelist')
    commit_parser.add_argument('-m', '--message', required=True, help='Commit message')
    commit_parser.set_defaults(func=cl_commit)

    args = parser.parse_args()
    args.func(args)

if __name__ == '__main__':
    main()
