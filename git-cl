#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# BSD 3-Clause License
#
# Copyright (c) 2025, Bjoern Hendrik Fock
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# pylint: disable=invalid-name
# pylint: disable=too-many-lines
#
"""
git-cl: Manage changelists within a Git working directory.

Repository: https://github.com/BHFock/git-cl
Note: This project may or may not be actively maintained in the future.

This CLI tool allows you to group files into named changelists before staging
or committing. Changelists are saved in a 'cl.json' file inside the Git
directory. You can then operate on changelists as logical groups: staging,
committing, listing, or deleting them.

Features:
- Add/remove files to/from changelists
- Stage or commit all files in a changelist
- Show status grouped by changelists
- Delete changelists when done

This tool is intended for use within Git repositories.
"""

__version__ = "0.2.6"

import argparse
import json
import sys
import os
import subprocess
import fcntl
import datetime
from typing import Optional
from pathlib import Path
from contextlib import contextmanager

# Try to import colorama for colored output
try:
    from colorama import Fore, Style
    COLORAMA_AVAILABLE = True
except ImportError:
    COLORAMA_AVAILABLE = False

    # Define dummy objects to avoid NameError
    # pylint: disable=too-few-public-methods
    class _DummyColorama:
        CYAN = ""
        GREEN = ""
        YELLOW = ""
        MAGENTA = ""
        RESET_ALL = ""

    Fore = _DummyColorama()
    Style = _DummyColorama()

# =============================================================================
# INTERNAL UTILITIES
# =============================================================================


@contextmanager
def clutil_file_lock(lock_path: Path):
    """
    Acquires an exclusive lock on a file for safe concurrent access.

    Args:
        lock_path (Path): Path to the lock file.

    Yields:
        None
    """
    with open(lock_path, 'w', encoding='utf-8') as lock_file:
        fcntl.flock(lock_file, fcntl.LOCK_EX)
        try:
            yield
        finally:
            fcntl.flock(lock_file, fcntl.LOCK_UN)


def clutil_should_use_color(args) -> bool:
    """
    Determines whether coloured output should be used in CLI display.

    This function checks multiple conditions to decide if colour formatting
    is appropriate:
    - The --no-color flag is not set.
    - The NO_COLOR environment variable is not set.
    - The output is being sent to a terminal (TTY).
    - The 'colorama' module is available.

    Args:
        args (argparse.Namespace): Parsed command-line arguments, expected to
                                   include the 'no_color' attribute.

    Returns:
        bool: True if coloured output should be enabled, False otherwise.
    """
    no_color_env = bool(os.environ.get('NO_COLOR'))
    is_tty = sys.stdout.isatty()
    return (not (args.no_color or no_color_env or not is_tty) and
            COLORAMA_AVAILABLE)


def clutil_resolve_commit_message(args: argparse.Namespace) -> Optional[str]:
    """
    Resolves the commit message from CLI arguments.

    Args:
        args (argparse.Namespace): Parsed arguments with 'message' or 'file'.

    Returns:
        Optional[str]: The commit message, or None if resolution fails.
    """
    if args.message:
        return args.message

    if args.file:
        try:
            return clutil_read_commit_message_file(args.file)
        except (OSError, ValueError) as error:
            print(f"Error reading commit message file '{args.file}': {error}")
            return None

    print("Error: No commit message provided.")
    return None


def clutil_get_file() -> Path:
    """
    Returns the path to the changelist file inside the Git directory.

    Returns:
        Path: Path to the '.git/cl.json' file.

    Raises:
        SystemExit: If not inside a Git repository.
    """
    try:
        git_dir = subprocess.check_output(
            ["git", "rev-parse", "--git-dir"],
            stderr=subprocess.DEVNULL,
            text=True
        ).strip()
        return Path(git_dir) / "cl.json"
    except subprocess.CalledProcessError:
        print("Error: Not inside a Git repository.")
        print("Please run this command from within a Git repository.")
        sys.exit(1)


def clutil_load() -> dict[str, list[str]]:
    """
    Loads changelist data from the 'cl.json' file.

    Returns:
        dict: A mapping of changelist names to lists of file paths.
    """
    cl_file = clutil_get_file()
    lock_file = cl_file.with_suffix('.lock')
    if cl_file.exists():
        with clutil_file_lock(lock_file):
            try:
                with open(cl_file, "r", encoding="utf-8") as file_handle:
                    return json.load(file_handle)
            except (json.JSONDecodeError, OSError) as error:
                print(f"Error reading changelists: {error}")
                return {}
    return {}


def clutil_save(data: dict[str, list[str]]) -> None:
    """
    Saves the changelist data to 'cl.json', omitting empty changelists.

    Args:
        data (dict): Mapping of changelist names to lists of files.
    """
    cl_file = clutil_get_file()
    lock_file = cl_file.with_suffix('.lock')
    cleaned = {k: v for k, v in data.items() if v}
    with clutil_file_lock(lock_file):
        try:
            with open(cl_file, "w", encoding="utf-8") as file_handle:
                json.dump(cleaned, file_handle, indent=2)
        except OSError as error:
            print(f"Error saving changelists: {error}")


def clutil_validate_name(name: str) -> bool:
    """
    Validates that a changelist name is safe to use.

    Args:
        name (str): The changelist name to validate.

    Returns:
        bool: True if the name is valid, False otherwise.
    """
    # Check for empty names
    if not name:
        return False

    # Check for reasonable length (max 100 characters)
    if len(name) > 100:
        return False

    # Only allow safe characters: letters, numbers, hyphens, underscores, dots
    allowed_chars = set(
        'abcdefghijklmnopqrstuvwxyz'
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        '0123456789-_.'
    )

    if not all(char in allowed_chars for char in name):
        return False

    # Don't allow names that are only dots (filesystem issues)
    if all(char == '.' for char in name):
        return False

    # Check for Git reserved words (only the critical ones)
    reserved_names = {'HEAD', 'FETCH_HEAD', 'ORIG_HEAD', 'MERGE_HEAD',
                      'CHERRY_PICK_HEAD', 'index'}
    if name in reserved_names:
        return False

    return True


def clutil_get_git_root() -> Path:
    """
    Returns the absolute path to the root of the current Git repository.

    Returns:
        Path: The top-level directory of the Git repository.

    Raises:
        SystemExit: If the current directory is not inside a Git repository.
    """
    try:
        return Path(
            subprocess.check_output(
                ["git", "rev-parse", "--show-toplevel"],
                text=True
            ).strip()
        ).resolve()
    except subprocess.CalledProcessError as error:
        print(f"Error: Not inside a Git repository. {error}")
        sys.exit(1)


def clutil_get_git_status(include_untracked: bool = False) -> list[str]:
    """
    Returns the output of 'git status --porcelain' as a list of lines.

    Args:
        include_untracked (bool): If True, includes untracked files using
                                  '--untracked-files=all'.

    Returns:
        list[str]: Each line represents a file's status.

    Raises:
        SystemExit: If the git command fails.
    """
    cmd = ["git", "status", "--porcelain"]
    if include_untracked:
        cmd.append("--untracked-files=all")

    try:
        return subprocess.check_output(cmd, text=True).splitlines()
    except subprocess.CalledProcessError as error:
        print(f"Error getting git status: {error}")
        sys.exit(1)


def clutil_sanitize_path(file_path: str, git_root: Path) -> Optional[str]:
    """
    Sanitizes and validates a file path for safe use with Git commands.

    Args:
        file_path (str): The file path to sanitize
        git_root (Path): The root directory of the Git repository

    Returns:
        str | None: The sanitized path relative to git_root, or None if invalid
    """
    try:
        # Convert to Path object and resolve any relative components
        path = Path(file_path)

        # If it's relative, make it relative to current working directory
        if not path.is_absolute():
            path = Path.cwd() / path

        # Resolve any .. or . components and get absolute path
        path = path.resolve()

        # Ensure the path is within the Git repository
        try:
            relative_path = path.relative_to(git_root)
        except ValueError:
            # Path is outside the Git repository
            return None

        # Convert back to string using forward slashes (Git standard)
        sanitized = relative_path.as_posix()

        # Basic security check: reject paths with dangerous characters
        dangerous_chars = [';', '|', '&', '`', '$', '\n', '\r', '\0']
        if any(char in sanitized for char in dangerous_chars):
            return None

        return sanitized

    except (OSError, ValueError, RuntimeError):
        # Any path resolution errors
        return None


def clutil_get_file_status_map(show_all: bool = False) -> dict[str, str]:
    """
    Get a mapping of files to their Git 2-letter status codes.

    By default, only a predefined set of common status codes are included.
    Files with uncommon status codes (e.g. merge conflicts, type changes)
    are skipped and counted for a warning message â€” unless `--all` is used.

    Ignored files (status code '! ') are silently excluded from both the
    output and the warning, since `git status --porcelain` does not include
    them unless explicitly requested with `--ignored`.

    Args:
        show_all (bool): If True, include all files regardless of status code.

    Returns:
        dict[str, str]: Mapping of relative file paths
                        to their Git status codes.
    """
    git_root = clutil_get_git_root()
    output = clutil_get_git_status(include_untracked=True)

    # Allowlist of known meaningful status codes
    INTERESTING_CODES = {
        '??', ' M', 'M ', 'MM', 'A ', 'AM', ' D', 'D ', 'R ', 'RM'
    }

    status_map = {}
    skipped = {}

    for line in output:
        if len(line) < 4:
            continue  # malformed line, ignore
        code = line[:2]
        raw_path = line[3:].strip()

        # Handle renamed files
        if code.startswith('R') and '->' in raw_path:
            raw_path = raw_path.split('->')[-1].strip()

        abs_path = (git_root / raw_path).resolve()
        try:
            rel_path = abs_path.relative_to(git_root).as_posix()
        except ValueError:
            rel_path = raw_path

        if show_all or code in INTERESTING_CODES:
            status_map[rel_path] = code
        else:
            skipped.setdefault(code, []).append(rel_path)

    if skipped and not show_all:
        skipped_count = sum(len(v) for v in skipped.values())
        print(f"Note: {skipped_count} file(s) with uncommon Git status codes "
              "were not shown. Use 'git cl st --all' to include them.")

    return status_map


def clutil_format_file_status(
        file: str, status_map: dict[str, str], git_root: Path,
        use_color: bool = True) -> str:
    """
    Format a file's Git status line with optional color-coded output.
    Paths are shown relative to the current working directory.
    """
    abs_file = (git_root / file).resolve()
    rel_to_cwd = os.path.relpath(abs_file, Path.cwd())

    rel_to_git_root = abs_file.relative_to(git_root).as_posix()
    status = status_map.get(rel_to_git_root, "  ")
    tag = f"[{status}]"

    if not use_color or not COLORAMA_AVAILABLE:
        return f"  {tag} {rel_to_cwd}"

    staged, unstaged = status[0], status[1]

    if status == "??":
        color = Fore.BLUE
    elif staged == 'A':
        color = Fore.GREEN
    elif staged != " " and unstaged == " ":
        color = Fore.GREEN
    elif staged == " " and unstaged != " ":
        color = Fore.RED
    elif staged != " " and unstaged != " ":
        color = Fore.MAGENTA
    else:
        color = Style.RESET_ALL

    return f"{color}  {tag} {rel_to_cwd}{Style.RESET_ALL}"


def clutil_read_commit_message_file(file_path: str) -> str:
    """
    Reads a commit message from a file, with validation and processing.

    Args:
        file_path (str): Path to the file containing the commit message

    Returns:
        str: The commit message content

    Raises:
        OSError: If the file cannot be read
        ValueError: If the file is empty or contains only whitespace
    """
    try:
        # Resolve path relative to current working directory
        path = Path(file_path).resolve()

        # Basic security check - ensure file exists and is readable
        if not path.exists():
            raise OSError(f"File does not exist: {file_path}")

        if not path.is_file():
            raise OSError(f"Path is not a file: {file_path}")

        # Reasonable size limit for commit messages (generous 64KB)
        if path.stat().st_size > 64 * 1024:
            raise ValueError("Commit message file too large (>64KB)")

        # Read the file
        with open(path, 'r', encoding='utf-8') as f:
            content = f.read(64 * 1024)  # Enforce the same limit

    except (OSError, UnicodeDecodeError) as error:
        raise OSError(f"Cannot read file: {error}") from error

    # Validate content
    if not content or not content.strip():
        raise ValueError(
            "Commit message file is empty or contains only whitespace")

    # Process the content similar to how Git does it:
    # - Strip trailing whitespace from each line
    # - Remove trailing empty lines
    lines = [line.rstrip() for line in content.splitlines()]

    # Remove trailing empty lines
    while lines and not lines[-1]:
        lines.pop()

    if not lines:
        raise ValueError(
            "Commit message file contains no content after processing")

    # Join lines back together
    processed_content = '\n'.join(lines)

    return processed_content


def clutil_is_file_untracked(
        file_path_rel_to_git_root: str, git_root: Path) -> bool:
    """
    Check if a file (specified relative to git root) is untracked.

    Args:
        file_path_rel_to_git_root: File path relative to git repository root
        git_root: Absolute path to git repository root

    Returns:
        True if the file is untracked, False if it's tracked
    """
    # Get git status output
    output = clutil_get_git_status(include_untracked=True)

    # Get absolute path of the file we're checking
    abs_file_path = (git_root / file_path_rel_to_git_root).resolve()

    # Check untracked files and directories
    for line in output:
        if line.startswith("??"):
            raw_path = line[3:].strip()
            abs_untracked = (git_root / raw_path).resolve()

            # Direct match for files
            if abs_file_path == abs_untracked:
                return True

            # Check if file is under an untracked directory
            if (
                abs_untracked.is_dir()
                and abs_file_path.is_relative_to(abs_untracked)
            ):
                return True

    return False


def clutil_get_stash_file() -> Path:
    """
    Returns the path to the stash metadata file inside the Git directory.

    Returns:
        Path: Path to the '.git/cl-stashes.json' file.
    """
    git_dir = Path(subprocess.check_output(
        ["git", "rev-parse", "--git-dir"],
        stderr=subprocess.DEVNULL,
        text=True
    ).strip())
    return git_dir / "cl-stashes.json"


def clutil_load_stashes() -> dict[str, dict]:
    """
    Loads stash metadata from the 'cl-stashes.json' file.

    Returns:
        dict: A mapping of stashed changelist names to their metadata.
    """
    stash_file = clutil_get_stash_file()
    lock_file = stash_file.with_suffix('.lock')
    if stash_file.exists():
        with clutil_file_lock(lock_file):
            try:
                with open(stash_file, "r", encoding="utf-8") as file_handle:
                    return json.load(file_handle)
            except (json.JSONDecodeError, OSError) as error:
                print(f"Error reading stash metadata: {error}")
                return {}
    return {}


def clutil_save_stashes(data: dict[str, dict]) -> None:
    """
    Saves the stash metadata to 'cl-stashes.json'.

    Args:
        data (dict): Mapping of stashed changelist names to metadata.
    """
    stash_file = clutil_get_stash_file()
    lock_file = stash_file.with_suffix('.lock')
    with clutil_file_lock(lock_file):
        try:
            with open(stash_file, "w", encoding="utf-8") as file_handle:
                json.dump(data, file_handle, indent=2)
        except OSError as error:
            print(f"Error saving stash metadata: {error}")


def clutil_check_files_unstaged(files: list[str], git_root: Path) -> tuple[list[str], list[str]]:
    """
    Check which files in the list have staged vs unstaged changes.
    
    Args:
        files: List of file paths relative to git root
        git_root: Path to git repository root
        
    Returns:
        tuple: (unstaged_files, staged_files) - files that can/cannot be stashed
    """
    status_map = clutil_get_file_status_map(show_all=True)
    
    unstaged_files = []
    staged_files = []
    
    for file_path in files:
        abs_path = (git_root / file_path).resolve()
        if not abs_path.exists():
            continue
            
        rel_to_git_root = abs_path.relative_to(git_root).as_posix()
        status = status_map.get(rel_to_git_root, "  ")
        
        # Check if file has staged changes (first character is not space)
        if status[0] != " ":
            staged_files.append(file_path)
        else:
            unstaged_files.append(file_path)
    
    return unstaged_files, staged_files


def clutil_check_unstash_conflicts(files: list[str], git_root: Path) -> list[str]:
    """
    Check which files have been modified since stashing.
    
    Args:
        files: List of file paths relative to git root
        git_root: Path to git repository root
        
    Returns:
        list: Files that have changes and might conflict
    """
    status_map = clutil_get_file_status_map(show_all=True)
    modified_files = []
    
    for file_path in files:
        abs_path = (git_root / file_path).resolve()
        if not abs_path.exists():
            continue
            
        rel_to_git_root = abs_path.relative_to(git_root).as_posix()
        status = status_map.get(rel_to_git_root, "  ")
        
        # File has changes if either staged or unstaged (not "  ")
        if status != "  ":
            modified_files.append(file_path)
    
    return modified_files


def clutil_find_stash_by_message(message: str) -> Optional[str]:
    """
    Find a stash reference by its commit message.
    
    Args:
        message: The stash message to search for
        
    Returns:
        The stash reference (e.g. "stash@{0}") or None if not found
    """
    try:
        stash_list = subprocess.check_output(["git", "stash", "list"], text=True)
        for line in stash_list.strip().split('\n'):
            if line and message in line:
                return line.split(':')[0]
    except subprocess.CalledProcessError:
        pass
    return None


# =============================================================================
# CLI COMMANDS
# =============================================================================


def cl_add(args: argparse.Namespace) -> None:
    """
    Adds one or more files to the specified changelist, creating it if needed.
    Prevents adding files that are in stashed changelists.
    """
    if not clutil_validate_name(args.name):
        print(
            f"Error: Invalid changelist name '{args.name}'. Names cannot "
            "contain special characters or be Git reserved words.")
        return
    
    changelists = clutil_load()
    stashes = clutil_load_stashes()
    git_root = clutil_get_git_root()
    
    files = []
    for file in args.files:
        sanitized = clutil_sanitize_path(file, git_root)
        if sanitized:
            files.append(sanitized)
        else:
            print(f"Warning: Skipping invalid or unsafe path: '{file}'")

    # Check if any files are in stashed changelists
    blocked_files = []
    for file_path in files:
        for stash_name, stash_data in stashes.items():
            if file_path in stash_data['files']:
                blocked_files.append((file_path, stash_name))
    
    if blocked_files:
        print("Error: Cannot add files that are in stashed changelists:")
        for file_path, stash_name in blocked_files:
            print(f"  {file_path} (in stashed changelist '{stash_name}')")
        print("Unstash the changelist first if you want to modify it.")
        return

    if args.name not in changelists:
        changelists[args.name] = []
    
    for file in files:
        # Remove from other active changelists
        for clist in changelists.values():
            if file in clist:
                clist.remove(file)
        if file not in changelists[args.name]:
            changelists[args.name].append(file)
    
    clutil_save(changelists)
    print(f"Added to '{args.name}': {files}")


def cl_stage(args: argparse.Namespace) -> None:
    """
    Stages all tracked files in the given changelist and optionally
    deletes the changelist.

    Args:
        args: argparse.Namespace with 'name' and 'delete' attributes.
    """
    changelists = clutil_load()
    name = args.name
    if name not in changelists:
        print(f"Changelist '{name}' not found.")
        return

    git_root = clutil_get_git_root()
    to_stage = []

    for stored_path in changelists[name]:
        # Convert stored path (relative to git root) to absolute path
        abs_path = (git_root / stored_path).resolve()

        if not abs_path.exists():
            print(f"Warning: '{stored_path}' does not exist.")
            continue

        # Convert to path relative to current working directory for Git command
        rel_to_cwd = os.path.relpath(abs_path, Path.cwd())

        # Check if this file is tracked (not untracked)
        if not clutil_is_file_untracked(stored_path, git_root):
            to_stage.append(rel_to_cwd)

    if not to_stage:
        print(f"No tracked files to stage in changelist '{name}'.")
        return

    try:
        subprocess.run(["git", "add", "--"] + to_stage, check=True)
        print(f"Staged tracked files from changelist '{name}':")
        for file in to_stage:
            print(f"  {file}")
    except subprocess.CalledProcessError as error:
        print(f"Error staging files: {error}")
        return

    # Only delete if --delete flag is set
    if args.delete:
        del changelists[name]
        clutil_save(changelists)
        print(f"Deleted changelist '{name}'")


def cl_unstage(args: argparse.Namespace) -> None:
    """
    Unstages all staged files in the specified changelist, moving them back
    to the working directory as unstaged changes.

    Args:
        args: argparse.Namespace with 'name' and 'keep' attributes.
    """
    changelists = clutil_load()
    name = args.name
    if name not in changelists:
        print(f"Changelist '{name}' not found.")
        return

    git_root = clutil_get_git_root()
    to_unstage = []

    # Get current status to identify staged files
    status_map = clutil_get_file_status_map(show_all=True)

    for stored_path in changelists[name]:
        # Convert stored path (relative to git root) to absolute path
        abs_path = (git_root / stored_path).resolve()

        if not abs_path.exists():
            print(f"Warning: '{stored_path}' does not exist.")
            continue

        # Convert to path relative to current working directory for Git command
        rel_to_cwd = os.path.relpath(abs_path, Path.cwd())

        # Check if this file has staged changes
        rel_to_git_root = abs_path.relative_to(git_root).as_posix()
        status = status_map.get(rel_to_git_root, "  ")

        # File has staged changes if first character is not space
        if status[0] != " ":
            to_unstage.append(rel_to_cwd)

    if not to_unstage:
        print(f"No staged files to unstage in changelist '{name}'.")
        return

    try:
        # Use git reset HEAD to unstage files
        subprocess.run(["git", "reset", "HEAD", "--"] + to_unstage, check=True)
        print(f"Unstaged files from changelist '{name}':")
        for file in to_unstage:
            print(f"  {file}")
    except subprocess.CalledProcessError as error:
        print(f"Error unstaging files: {error}")
        return

    # Only delete if --delete flag is set
    if args.delete:
        del changelists[name]
        clutil_save(changelists)
        print(f"Deleted changelist '{name}'")


def cl_status(args: argparse.Namespace) -> None:
    """
    Displays git status grouped by changelist membership, including stashed changelists.
    """
    selected_names = set(args.names) if args.names else None
    changelists = clutil_load()
    stashes = clutil_load_stashes()
    git_root = clutil_get_git_root()
    st_map = clutil_get_file_status_map(show_all=args.all)

    use_color = clutil_should_use_color(args)

    assigned_files = set()

    # Show active changelists first
    for cl_name, files in changelists.items():
        if selected_names is not None and cl_name not in selected_names:
            continue
        if cl_name.endswith('_stashed'):
            continue  # Skip, we'll show these in stashed section
        print(f"{cl_name}:")
        for file in files:
            print(clutil_format_file_status(file, st_map, git_root, use_color))
        for f in files:
            try:
                abs_path = (git_root / f).resolve()
                rel_path = abs_path.relative_to(git_root).as_posix()
                assigned_files.add(rel_path)
            except (ValueError, OSError) as error:
                print(f"Error resolving path: {error}")

    # Show stashed changelists section
    stashed_changelists = []
    for cl_name, files in changelists.items():
        if cl_name.endswith('_stashed'):
            stashed_changelists.append(cl_name)
    
    if stashed_changelists:
        print("\nStashed Changelists:")
        for stashed_name in sorted(stashed_changelists):
            base_name = stashed_name.rstrip('_stashed')
            if base_name in stashes:
                stash_data = stashes[base_name]
                file_count = len(stash_data['files'])
                timestamp = stash_data.get('timestamp', 'unknown')
                print(f"  {stashed_name} ({file_count} files, {timestamp})")
            else:
                print(f"  {stashed_name} (metadata missing)")

    # Show unassigned files
    if selected_names is None or args.include_no_cl:
        no_cl_files = [file for file in st_map if file not in assigned_files]
        if no_cl_files:
            print("\nNo Changelist:")
            for file in sorted(no_cl_files):
                print(clutil_format_file_status(file, st_map, git_root, use_color))


def cl_diff(args: argparse.Namespace) -> None:
    """
    Show git diff for one or more changelists.

    By default, shows unstaged changes (like `git diff`).
    Use --staged for staged changes, or --both to show both.

    Args:
        args: argparse.Namespace with 'names' list of changelists,
              and optional 'staged' and 'both' flags
    """
    changelists = clutil_load()
    git_root = clutil_get_git_root()
    diff_files = set()

    for name in args.names:
        if name not in changelists:
            print(f"Changelist '{name}' not found.")
            continue
        for path in changelists[name]:
            abs_path = (git_root / path).resolve()
            if abs_path.exists():
                rel_to_cwd = os.path.relpath(abs_path, Path.cwd())
                diff_files.add(rel_to_cwd)
            else:
                print(f"Warning: File '{path}' from '{name}' does not exist.")

    if not diff_files:
        print("No valid files to diff.")
        return

    sorted_files = sorted(diff_files)

    try:
        if args.both:
            # Show both unstaged and staged diffs
            print("=== Unstaged changes (working tree vs index) ===")
            subprocess.run(["git", "diff", "--"] + sorted_files, check=False)
            print("\n=== Staged changes (index vs HEAD) ===")
            subprocess.run(["git", "diff", "--staged", "--"] + sorted_files,
                           check=False)
        elif args.staged:
            # Show only staged changes
            subprocess.run(["git", "diff", "--staged", "--"] + sorted_files,
                           check=False)
        else:
            # Default: show unstaged changes
            subprocess.run(["git", "diff", "--"] + sorted_files, check=False)
    except subprocess.CalledProcessError as error:
        print(f"Error running git diff: {error}")


def cl_remove(args: argparse.Namespace) -> None:
    """
    Removes one or more files from any changelists they are part of.

    Args:
        args: argparse.Namespace with 'files' attribute.
    """
    changelists = clutil_load()
    removed = []

    git_root = clutil_get_git_root()
    for file in args.files:
        sanitized = clutil_sanitize_path(file, git_root)
        if sanitized is None:
            print(f"Warning: Skipping invalid or unsafe path: '{file}'")
            continue

        found = False
        for name, files in changelists.items():
            if sanitized in files:
                files.remove(sanitized)
                removed.append(sanitized)
                print(f"Removed '{sanitized}' from changelist '{name}'")
                found = True
                break  # Stop after first match

        if not found:
            print(f"'{file}' was not found in any changelist.")

    if removed:
        clutil_save(changelists)


def cl_delete(args: argparse.Namespace) -> None:
    """
    Deletes one or more changelists by name, or all with --all.
    """
    changelists = clutil_load()

    if args.all and args.names:
        print("Error: Cannot specify changelist names and --all together.")
        return

    if args.all:
        if not changelists:
            print("No changelists to delete.")
            return
        count = len(changelists)
        changelists.clear()
        clutil_save(changelists)
        print(f"Deleted all {count} changelists.")
        return

    if not args.names:
        print("Error: No changelist names provided.")
        return

    deleted = False
    for name in args.names:
        if name in changelists:
            del changelists[name]
            print(f"Deleted changelist '{name}'")
            deleted = True
        else:
            print(f"Changelist '{name}' not found.")

    if deleted:
        clutil_save(changelists)


def cl_commit(args: argparse.Namespace) -> None:
    """
    Commits all tracked files in the specified changelist, then optionally
    deletes it.

    Args:
        args: argparse.Namespace with 'name', 'message'/'file',
              and 'keep' attributes.
    """
    changelists = clutil_load()
    name = args.name
    if name not in changelists:
        print(f"Changelist '{name}' not found.")
        return

    git_root = clutil_get_git_root()
    to_commit = []

    for stored_path in changelists[name]:
        # Convert stored path (relative to git root) to absolute path
        abs_path = (git_root / stored_path).resolve()

        if not abs_path.exists():
            print(f"Warning: '{stored_path}' does not exist.")
            continue

        # Convert to path relative to current working directory for Git command
        rel_to_cwd = os.path.relpath(abs_path, Path.cwd())

        # Check if this file is tracked (not untracked)
        if not clutil_is_file_untracked(stored_path, git_root):
            to_commit.append(rel_to_cwd)

    if not to_commit:
        print(f"No tracked files to commit in changelist '{name}'.")
        return

    commit_message = clutil_resolve_commit_message(args)
    if not commit_message:
        return

    try:
        subprocess.run(["git", "commit", "-m", commit_message, "--"]
                       + to_commit, check=True)
        print(f"Committed tracked files from changelist '{name}':")
        for file in to_commit:
            print(f"  {file}")
    except subprocess.CalledProcessError as error:
        print(f"Error committing changelist '{name}': {error}")
        return

    if not args.keep:
        del changelists[name]
        clutil_save(changelists)
        print(f"Deleted changelist '{name}'")
    else:
        print(f"Kept changelist '{name}' (use --keep flag to preserve)")


def cl_stash(args: argparse.Namespace) -> None:
    """
    Stash all unstaged changes for files in the specified changelist.
    Only allows stashing if all files in the changelist are unstaged.
    
    Args:
        args: argparse.Namespace with 'name' attribute.
    """
    changelists = clutil_load()
    stashes = clutil_load_stashes()
    name = args.name
    
    # Pre-validation Step 1: Check if changelist exists
    if name not in changelists:
        print(f"Changelist '{name}' not found.")
        return
    
    # Pre-validation Step 2: Check if changelist is already stashed
    if name in stashes:
        print(f"Changelist '{name}' is already stashed.")
        print(f"Use 'git cl unstash {name}' to restore it first.")
        return
    
    git_root = clutil_get_git_root()
    files = changelists[name]
    
    # Pre-validation Step 3: Check if changelist is empty
    if not files:
        print(f"Changelist '{name}' is empty - nothing to stash.")
        return
    
    # Pre-validation Step 4: Check that all files exist
    missing_files = []
    existing_files = []
    for stored_path in files:
        abs_path = (git_root / stored_path).resolve()
        if not abs_path.exists():
            missing_files.append(stored_path)
        else:
            existing_files.append((stored_path, abs_path))
    
    if missing_files:
        print(f"Error: Cannot stash changelist '{name}' because these files no longer exist:")
        for file_path in missing_files:
            print(f"  {file_path}")
        print("Remove these files from the changelist first using 'git cl remove'.")
        return
    
    # Pre-validation Step 5: Check that all files have only unstaged changes
    unstaged_files, staged_files = clutil_check_files_unstaged([f[0] for f in existing_files], git_root)
    
    if staged_files:
        print(f"Error: Cannot stash changelist '{name}' because these files have staged changes:")
        for file_path in staged_files:
            print(f"  {file_path}")
        print("Please unstage the files first using 'git cl unstage' or commit them separately.")
        return
    
    # Pre-validation Step 6: Check if there are actually any changes to stash
    status_map = clutil_get_file_status_map(show_all=True)
    files_with_changes = []
    for stored_path, abs_path in existing_files:
        rel_to_git_root = abs_path.relative_to(git_root).as_posix()
        status = status_map.get(rel_to_git_root, "  ")
        # File has unstaged changes if second character is not space (and not untracked)
        if status != "  " and status != "??":
            files_with_changes.append(stored_path)
    
    if not files_with_changes:
        print(f"No changes to stash in changelist '{name}' - all files are clean.")
        return
    
    # All pre-validation passed - proceed with stashing
    print(f"Stashing {len(files_with_changes)} file(s) with changes from changelist '{name}'...")
    
    # Convert file paths to relative-to-cwd for git command (only files with changes)
    files_for_git = []
    for stored_path in files_with_changes:
        abs_path = (git_root / stored_path).resolve()
        rel_to_cwd = os.path.relpath(abs_path, Path.cwd())
        files_for_git.append(rel_to_cwd)
    
    # Create the stash
    stash_message = f"git-cl: stash for changelist '{name}'"
    try:
        # Use git stash push to stash only specific files
        cmd = ["git", "stash", "push", "-m", stash_message, "--"] + files_for_git
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        
        # This shouldn't happen due to pre-validation, but double-check
        if "No local changes to save" in result.stderr:
            print(f"Unexpected: No changes were stashed for changelist '{name}'.")
            return
        
    except subprocess.CalledProcessError as error:
        print(f"Error creating stash: {error}")
        if error.stderr:
            print(f"Git error: {error.stderr}")
        return
    
    # Get the actual stash reference from git stash list
    try:
        stash_list = subprocess.check_output(["git", "stash", "list"], text=True)
        lines = stash_list.strip().split('\n')
        if lines and lines[0]:
            stash_ref = lines[0].split(':')[0]  # Extract "stash@{0}" part
        else:
            print("Error: Could not find created stash.")
            return
    except subprocess.CalledProcessError:
        print("Error: Could not list stashes.")
        return
    
    # Save stash metadata (this should be atomic with changelist modification)
    try:
        stashes[name] = {
            "stash_ref": stash_ref,
            "files": files.copy(),
            "timestamp": datetime.datetime.now().isoformat()
        }
        clutil_save_stashes(stashes)
        
        # Remove the changelist from active changelists
        del changelists[name]
        clutil_save(changelists)
        
    except Exception as error:
        print(f"Error saving stash metadata: {error}")
        print(f"Stash was created as {stash_ref} but metadata wasn't saved.")
        print("You may need to manually clean up the stash.")
        return
    
    print(f"Successfully stashed changelist '{name}'")
    print(f"Stashed {len(files_with_changes)} file(s) with changes:")
    for file_path in files_with_changes:
        print(f"  {file_path}")
    print(f"Use 'git cl unstash {name}' to restore the changelist.")


def cl_unstash(args: argparse.Namespace) -> None:
    """
    Restore a stashed changelist to the working directory.
    
    Args:
        args: argparse.Namespace with 'name' and optional 'force' attributes.
    """
    stashes = clutil_load_stashes()
    changelists = clutil_load()
    name = args.name
    
    # Handle both "name" and "name_stashed" formats
    if name.endswith("_stashed"):
        base_name = name[:-8]  # Remove "_stashed" suffix
        stash_key = base_name
    else:
        base_name = name
        stash_key = name
    
    if stash_key not in stashes:
        print(f"No stashed changelist found for '{base_name}'.")
        available = list(stashes.keys())
        if available:
            print("Available stashed changelists:")
            for stashed_name in available:
                print(f"  {stashed_name}")
        return
    
    stash_data = stashes[stash_key]
    stash_ref = stash_data["stash_ref"]
    files = stash_data["files"]
    
    # Check if target changelist name already exists
    if base_name in changelists and changelists[base_name]:
        print(f"Error: Changelist '{base_name}' already exists with files.")
        print("Please delete or rename the existing changelist first.")
        return
    
    git_root = clutil_get_git_root()
    
    # Check for conflicts unless --force is used
    if not getattr(args, 'force', False):
        modified_files = clutil_check_unstash_conflicts(files, git_root)
        if modified_files:
            print(f"Error: These files have been modified since stashing:")
            for file_path in modified_files:
                print(f"  {file_path}")
            print(f"\nUse 'git cl unstash {base_name} --force' to attempt merge anyway.")
            return
    
    # Apply the stash
    try:
        # Pop the specific stash
        subprocess.run(["git", "stash", "pop", stash_ref], check=True)
        
        # Restore the changelist
        changelists[base_name] = files.copy()
        
        # Remove stashed version if it exists
        stashed_name = f"{base_name}_stashed"
        if stashed_name in changelists:
            del changelists[stashed_name]
        
        clutil_save(changelists)
        
        # Remove from stash metadata
        del stashes[stash_key]
        clutil_save_stashes(stashes)
        
        print(f"Restored changelist '{base_name}' from stash")
        print(f"Restored {len(files)} file(s):")
        for file_path in files:
            print(f"  {file_path}")
            
    except subprocess.CalledProcessError as error:
        print(f"Error applying stash: {error}")
        print("The stash was not removed. You may need to resolve conflicts manually.")
        print(f"Try: git stash show {stash_ref}")
        print(f"Or: git stash drop {stash_ref}")


def cl_help(args: argparse.Namespace) -> None:
    """
    Displays the main help message using argparse's built-in formatting.
    """
    args.parser.print_help()


def main() -> None:
    """
    Entry point for the git-cl command-line interface.

    Parses command-line arguments and dispatches to the appropriate
    subcommand handler (e.g., add, remove, stage, commit, etc.).
    """
    parser = argparse.ArgumentParser(
        prog='git-cl',
        usage='git cl <command> [<args>]',
        description=(
            "git-cl: A Git subcommand for managing named changelists \n"
            "        Group files into logical changelists before staging "
            "or committing.\n\n"
            "        NOTE: Commit/stage commands only operate on tracked files"
            "\n              untracked files in changelists are safely "
            "ignored."),
        epilog=(
            "Example usage:\n"
            "    git cl add my-feature file1.py file2.py\n"
            "    git cl status\n"
            "    git cl commit my-feature -m 'Implement feature'\n\n"
            "See also: https://github.com/BHFock/git-cl"),
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False)

    parser.add_argument(
        '--version',
        action='version',
        version=f'git-cl {__version__}',
        help=argparse.SUPPRESS)

    subparsers = parser.add_subparsers(dest='command', title='Commands')

    # add
    add_parser = subparsers.add_parser('add', aliases=['a'],
                                       help='Add files to a named changelist',
                                       description=(
                                           "Add one or more files to a named "
                                           "changelist. If the changelist "
                                           "does not exist, it will be "
                                           "created automatically."))
    add_parser.add_argument('name', metavar='CHANGELIST',
                            help='Name of the changelist to add files to')
    add_parser.add_argument('files', metavar='FILE', nargs='+',
                            help=("One or more files to include "
                                  "in the changelist"))
    add_parser.set_defaults(func=cl_add)

    # remove
    remove_parser = subparsers.add_parser('remove', aliases=['r', 'rm'],
                                          help=("Remove files from any "
                                                "changelist"),
                                          description=("Removes files from "
                                                       "any changelists they "
                                                       "belong to."))
    remove_parser.add_argument('files', metavar='FILE', nargs='+',
                               help=("One or more files to remove "
                                     "from changelists"))
    remove_parser.set_defaults(func=cl_remove)

    # delete
    delete_parser = subparsers.add_parser('delete', aliases=['del'],
                                          help=("Delete one or more "
                                                "changelists"),
                                          description=(
                                              "Delete one or more changelists "
                                              "by name, or remove all with "
                                              "--all."))
    delete_parser.add_argument('names', metavar='CHANGELIST', nargs='*',
                               help=("One or more changelists to delete "
                                     "(required unless --all is used)"))
    delete_parser.add_argument('--all', action='store_true',
                               help='Delete all changelists')
    delete_parser.set_defaults(func=cl_delete)

    # status / st
    status_parser = subparsers.add_parser('status', aliases=['s', 'st'],
                                          help=("Show file changes grouped by "
                                                "changelist"),
                                          description=(
                                              "Show file changes grouped by "
                                              "changelist. Unassigned files "
                                              "appear under 'No Changelist'."))
    status_parser.add_argument('names', metavar='CHANGELIST', nargs='*',
                               help=("Optional list of changelists to show "
                                     "(default: all)"))
    status_parser.add_argument('--include-no-cl', action='store_true',
                               help=("When filtering by changelist names, "
                                     "also show files not assigned to any "
                                     "changelist"))
    status_parser.add_argument('--all', action='store_true',
                               help=("Include files with uncommon Git "
                                     "status codes"))
    status_parser.add_argument('--no-color', action='store_true',
                               help='Disable colored output')
    status_parser.set_defaults(func=cl_status)

    # diff
    diff_parser = subparsers.add_parser('diff',
                                        help=("Show git diff for one or more "
                                              "changelists"),
                                        description=(
                                            "Show unified diff for the files "
                                            "in one or more changelists. "
                                            "By default, shows unstaged "
                                            "changes (like `git diff`). "
                                            "Use --staged for staged changes, "
                                            "or --both to show both."))
    diff_parser.add_argument('names', metavar='CHANGELIST', nargs='+',
                             help='One or more changelists to diff')
    diff_parser.add_argument('--staged', action='store_true',
                             help='Show staged changes (index vs HEAD)')
    diff_parser.add_argument('--both', action='store_true',
                             help='Show both unstaged and staged diffs')
    diff_parser.set_defaults(func=cl_diff)

    # stage
    stage_parser = subparsers.add_parser('stage',
                                         help=("Stage tracked files from a "
                                               "changelist"),
                                         description=(
                                             "Stage all tracked files from "
                                             "the specified changelist. Only "
                                             "files already tracked by Git "
                                             "will be staged. Untracked files "
                                             "in the changelist are safely "
                                             "ignored and remain untracked. "
                                             "By default, the changelist is "
                                             "kept unless --delete is used."))
    stage_parser.add_argument('name', metavar='CHANGELIST',
                              help='Name of the changelist to stage')
    stage_parser.add_argument('--delete', action='store_true',
                              help='Delete the changelist after staging')
    stage_parser.set_defaults(func=cl_stage)

    # unstage
    unstage_parser = subparsers.add_parser('unstage',
                                           help=("Unstage tracked files from "
                                                 "a changelist"),
                                           description=(
                                               "Unstage all staged files from "
                                               "the specified changelist, "
                                               "moving them back to unstaged "
                                               "state in the working "
                                               "directory. By default, the "
                                               "changelist is kept unless "
                                               "--delete is used."))
    unstage_parser.add_argument('name', metavar='CHANGELIST',
                                help='Name of the changelist to unstage')
    unstage_parser.add_argument('--delete', action='store_true',
                                help='Delete the changelist after unstaging')
    unstage_parser.set_defaults(func=cl_unstage)

    # commit / ci
    commit_parser = subparsers.add_parser('commit', aliases=['ci'],
                                          help=("Commit tracked files from a "
                                                "changelist (auto-stages, "
                                                "ignores untracked)"),
                                          description=(
                                              "Stage and commit all tracked "
                                              "files from the specified "
                                              "changelist using the provided "
                                              "message. Untracked files in "
                                              "the changelist are ignored and "
                                              "remain untracked. By default, "
                                              "the changelist is deleted "
                                              "after committing unless --keep "
                                              "is used."))
    commit_parser.add_argument('name', metavar='CHANGELIST',
                               help='Name of the changelist to commit')
    msg_group = commit_parser.add_mutually_exclusive_group(required=True)
    msg_group.add_argument('-m', '--message',
                           help='Commit message')
    msg_group.add_argument('-F', '--file',
                           help='Read commit message from file')
    commit_parser.add_argument('--keep', action='store_true',
                               help='Keep the changelist after committing')
    commit_parser.set_defaults(func=cl_commit)

    # stash
    stash_parser = subparsers.add_parser('stash',
                                         help='Stash changes in a changelist',
                                         description=(
                                             "Stash all unstaged changes for files "
                                             "in the specified changelist. Only "
                                             "files with unstaged changes can be "
                                             "stashed. The changelist will be "
                                             "renamed to 'name_stashed' and shown "
                                             "in git cl status."))
    stash_parser.add_argument('name', metavar='CHANGELIST',
                              help='Name of the changelist to stash')
    stash_parser.set_defaults(func=cl_stash)

    # unstash
    unstash_parser = subparsers.add_parser('unstash',
                                           help='Restore a stashed changelist',
                                           description=(
                                               "Restore a previously stashed "
                                               "changelist to the working directory. "
                                               "If any files have been modified since "
                                               "stashing, use --force to attempt "
                                               "automatic merging."))
    unstash_parser.add_argument('name', metavar='CHANGELIST',
                                help=('Name of the changelist to unstash '
                                      '(with or without _stashed suffix)'))
    unstash_parser.add_argument('--force', action='store_true',
                                help='Force unstash even if files have changed')
    unstash_parser.set_defaults(func=cl_unstash)

    # help command
    help_parser = subparsers.add_parser('help',
                                        help='Show this help message',
                                        description=(
                                            "Displays a summary of "
                                            "available git-cl commands."))
    help_parser.set_defaults(func=cl_help, parser=parser)

    args = parser.parse_args()

    # If no command was provided, show help
    if args.command is None:
        parser.print_help()
        return

    # Provide parser to all commands in case needed
    if not hasattr(args, 'parser'):
        args.parser = parser

    args.func(args)


if __name__ == '__main__':
    main()
